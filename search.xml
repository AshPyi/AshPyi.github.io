<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线程篇</title>
      <link href="/2021/07/15/%E7%BA%BF%E7%A8%8B%E7%AF%87/"/>
      <url>/2021/07/15/%E7%BA%BF%E7%A8%8B%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="在-java-中守护线程和本地线程区别？"><a href="#在-java-中守护线程和本地线程区别？" class="headerlink" title="在 java 中守护线程和本地线程区别？"></a>在 java 中守护线程和本地线程区别？</h1><p>java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。</p><p>任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(布尔类型)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在 Thread.start()之前调用，否则运行时会抛出异常。</p><h2 id="两者的区别："><a href="#两者的区别：" class="headerlink" title="两者的区别："></a>两者的区别：</h2><p>唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可以理解为守护线程是 JVM自动创建的线程（但不一定），用户线程是程序创建的线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。</p><p><strong>扩展</strong>：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break 的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。</p><h1 id="线程与进程的区别？"><a href="#线程与进程的区别？" class="headerlink" title="线程与进程的区别？"></a>线程与进程的区别？</h1><p>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。</p><p>一个程序至少有一个进程,一个进程至少有一个线程。 </p><h1 id="什么是多线程中的上下文切换？"><a href="#什么是多线程中的上下文切换？" class="headerlink" title="什么是多线程中的上下文切换？"></a>什么是多线程中的上下文切换？</h1><p>多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU 发生的切换数据等就是上下文切换。</p><h1 id="死锁与活锁的区别，死锁与饥饿的区别？"><a href="#死锁与活锁的区别，死锁与饥饿的区别？" class="headerlink" title="死锁与活锁的区别，死锁与饥饿的区别？"></a>死锁与活锁的区别，死锁与饥饿的区别？</h1><p><strong>死锁</strong>：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p><blockquote><h2 id="产生死锁的必要条件："><a href="#产生死锁的必要条件：" class="headerlink" title="产生死锁的必要条件："></a>产生死锁的必要条件：</h2><ol><li><strong>互斥条件</strong>：所谓互斥就是进程在某一时间内独占资源。</li><li><strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 </li><li><strong>不剥夺条件</strong>:进程已获得资源，在末使用完之前，不能强行剥夺。 </li><li><strong>循环等待条件</strong>:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol></blockquote><p><strong>活锁</strong>：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p><strong>饥饿</strong>：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p><blockquote><h2 id="Java-中导致饥饿的原因："><a href="#Java-中导致饥饿的原因：" class="headerlink" title="Java 中导致饥饿的原因："></a>Java 中导致饥饿的原因：</h2><ol><li>高优先级线程吞噬所有的低优先级线程的 CPU 时间。 </li><li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。 </li><li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。</li></ol></blockquote><h1 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h1><p>采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。</p><h1 id="什么是线程组，为什么在-Java-中不推荐使用？"><a href="#什么是线程组，为什么在-Java-中不推荐使用？" class="headerlink" title="什么是线程组，为什么在 Java 中不推荐使用？"></a>什么是线程组，为什么在 Java 中不推荐使用？</h1><p>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p><p>为什么不推荐使用？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。</p><h1 id="为什么使用-Executor-框架？"><a href="#为什么使用-Executor-框架？" class="headerlink" title="为什么使用 Executor 框架？"></a><strong>为什么使用 Executor 框架？</strong></h1><p>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。</p><p>接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</p><h1 id="在-Java-中-Executor-和-Executors-的区别？"><a href="#在-Java-中-Executor-和-Executors-的区别？" class="headerlink" title="在 Java 中 Executor 和 Executors 的区别？"></a><strong>在 Java 中 Executor 和 Executors 的区别？</strong></h1><ol><li>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。 </li><li>Executor 接口对象能执行我们的线程任务。</li><li>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li><li>使用 ThreadPoolExecutor 可以创建自定义线程池</li><li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()`方法获取计算的结果。</li></ol><h1 id="什么是原子操作？在-Java-Concurrency-API-中有哪些原子类-atomic-classes-？"><a href="#什么是原子操作？在-Java-Concurrency-API-中有哪些原子类-atomic-classes-？" class="headerlink" title="什么是原子操作？在 Java Concurrency API 中有哪些原子类 (atomic classes)？"></a>什么是原子操作？在 Java Concurrency API 中有哪些原子类 (atomic classes)？</h1><p>原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。 </p><p>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p><p>在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。 CAS 操作——Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的 CPU 指令都支持 CAS 的原子操作。</p><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p><p>int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。</p><p>为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用同步技术来做到这一点。到 JDK1.5，java.util.concurrent.atomic 包提供了 int 和 long 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</p><p>java.util.concurrent 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。</p><p>原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference </p><p>原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray </p><p>原 子 属 性 更 新 器 ： AtomicLongFieldUpdater ， AtomicIntegerFieldUpdater ，AtomicReferenceFieldUpdater </p><p>解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个 boolean 来反映中间有没有变过），AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过）</p><h1 id="Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？-对比同步它有什么优势？"><a href="#Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？-对比同步它有什么优势？" class="headerlink" title="Java Concurrency API 中的 Lock 接口(Lock interface)是什么？ 对比同步它有什么优势？"></a><strong>Java Concurrency API 中的 Lock 接口(Lock interface)是什么？</strong> 对比同步它有什么优势？</h1><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。 </p><blockquote><p><strong>它的优势有：</strong> </p><ol><li>可以使锁更公平 </li><li>可以使线程在等待锁的时候响应中断 </li><li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间 </li><li>可以在不同的范围，以不同的顺序获取和释放锁 </li></ol></blockquote><p>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择</p><h1 id="什么是-Executors-框架？"><a href="#什么是-Executors-框架？" class="headerlink" title="什么是 Executors 框架？"></a><strong>什么是 Executors 框架？</strong></h1><p>Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。 无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用 Executors 框架可以非常方便的创建一个线程池。</p><h1 id="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队-列来实现生产者-消费者模型？"><a href="#什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队-列来实现生产者-消费者模型？" class="headerlink" title="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队 列来实现生产者-消费者模型？"></a><strong>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队</strong> <strong>列来实现生产者-消费者模型？</strong></h1><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p><p>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。 </p><blockquote><p>JDK7 提供了 7 个阻塞队列。分别是:</p><ol><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。 </li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 </li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。 </li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。 </li><li>SynchronousQueue：一个不存储元素的阻塞队列。 </li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 </li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ol></blockquote><p>Java5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized 这些关键字。而在 java5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p><p>BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue中放入元素，取出元素，它可以很好的控制线程之间的通信。</p><p>阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。</p><h1 id="什么是-Callable-和-Future"><a href="#什么是-Callable-和-Future" class="headerlink" title="什么是 Callable 和 Future?"></a><strong>什么是 Callable 和 Future?</strong></h1><p>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。 </p><p>可以认为是带有回调的 Runnable。</p><p>Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable 用于产生结果，Future 用于获取结果。</p><h1 id="什么是-FutureTask-使用-ExecutorService-启动任务。"><a href="#什么是-FutureTask-使用-ExecutorService-启动任务。" class="headerlink" title="什么是 FutureTask?使用 ExecutorService 启动任务。"></a><strong>什么是 FutureTask?使用 ExecutorService 启动任务。</strong></h1><p>在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnable 接口所以它可以提交给 Executor 来执行。</p><h1 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a><strong>什么是并发容器的实现？</strong></h1><p>何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行 。比如Vector ， Hashtable， 以及Collections.synchronizedSet，synchronizedList 等方法返回的容器。</p><p>可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized。并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。</p><h1 id="多线程同步和互斥有几种实现方法，都是什么？"><a href="#多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="多线程同步和互斥有几种实现方法，都是什么？"></a><strong>多线程同步和互斥有几种实现方法，都是什么？</strong></h1><p>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p><p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p><p>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</p><p><strong>用户模式下的方法有</strong>：原子操作（例如一个单一的全局变量），临界区。</p><p><strong>内核模式下的方法有</strong>：事件，信号量，互斥量。</p><h1 id="什么是竞争条件？你怎样发现和解决竞争？"><a href="#什么是竞争条件？你怎样发现和解决竞争？" class="headerlink" title="什么是竞争条件？你怎样发现和解决竞争？"></a><strong>什么是竞争条件？你怎样发现和解决竞争？</strong></h1><p>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（<code>race condition</code>）。</p><h1 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？"></a>为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？</h1><p>当你调用 start()方法时你将创建新的线程，并且执行在 run()方法里的代码。但是如果你直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run 方法当作普通方法去执行。</p><h1 id="Java-中你怎样唤醒一个阻塞的线程？"><a href="#Java-中你怎样唤醒一个阻塞的线程？" class="headerlink" title="Java 中你怎样唤醒一个阻塞的线程？"></a><strong>Java 中你怎样唤醒一个阻塞的线程？</strong></h1><p>在 Java 发展史上曾经使用 suspend()、resume()方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。</p><p>解决方案可以使用以对象为目标的阻塞，即利用 Object 类的 wait()和 notify()方法实现线程阻塞。</p><p>首先，wait、notify 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行；其次，wait、notify方法必须在 synchronized块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify方法的对象是同一个，如此一来在调用wait之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</p><h1 id="在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？"><a href="#在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？" class="headerlink" title="在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？"></a><strong>在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？</strong></h1><p>`CyclicBarrier 可以重复使用，而 CountdownLatch 不能重复使用。 </p><p>Java 的 concurrent 包里面的 CountDownLatch 其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。</p><p>可以向 CountDownLatch 对象设置一个初始的数字作为计数值，任何调用这个对象上的await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为 0 为止。</p><p>所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。</p><p>CountDownLatch 的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到 其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一 个 CountDownLatch 对象的 await()方法，其他的任务执行完自己的任务后调用同一个 CountDownLatch 对象上的 countDown()方法，这个调用 await()方法的任务将一直阻塞等待，直到这个 CountDownLatch 对象的计数值减到 0 为止</p><p>CyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点(common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</p><h1 id="什么是不可变对象，它对写并发应用有什么帮助？"><a href="#什么是不可变对象，它对写并发应用有什么帮助？" class="headerlink" title="什么是不可变对象，它对写并发应用有什么帮助？"></a><strong>什么是不可变对象，它对写并发应用有什么帮助？</strong></h1><ol><li>不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值） 就不能改变，反之即为可变对象(Mutable Objects)。</li><li>不可变对象的类即为不可变类(Immutable Class)。Java 平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger 和 BigDecimal 等。</li><li>不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变</li><li>不可变对象永远是线程安全的。</li><li>只有满足如下状态，一个对象才是不可变的；</li><li>它的状态不能在创建后再被修改；</li><li>所有域都是 final 类型；并且，它被正确创建（创建期间没有发生 this 引用的逸出）。</li></ol><h1 id="什么是多线程中的上下文切换？-1"><a href="#什么是多线程中的上下文切换？-1" class="headerlink" title="什么是多线程中的上下文切换？"></a><strong>什么是多线程中的上下文切换？</strong></h1><p>在上下文切换过程中，CPU 会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB 还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到 CPU 的内存中，直到他们被再次使用。</p><p>上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p><h1 id="Java-中用到的线程调度算法是什么？-1"><a href="#Java-中用到的线程调度算法是什么？-1" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a><strong>Java 中用到的线程调度算法是什么？</strong></h1><p>计算机通常只有一个 CPU,在任意时刻只能执行一条机器指令,每个线程只有获得 CPU 的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得 CPU 的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待 CPU,JAVA 虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配 CPU 的使用权.</p><p>有两种调度模型：分时调度模型和抢占式调度模型。</p><p>分时调度模型是指让所有的线程轮流获得 cpu 的使用权,并且平均分配每个线程占用的 CPU的时间片这个也比较好理解。</p><p>java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用 CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</p><h1 id="什么是线程组，为什么在-Java-中不推荐使用？-1"><a href="#什么是线程组，为什么在-Java-中不推荐使用？-1" class="headerlink" title="什么是线程组，为什么在 Java 中不推荐使用？"></a><strong>什么是线程组，为什么在 Java 中不推荐使用？</strong></h1><p>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。 </p><h1 id="为什么使用-Executor-框架比使用应用创建和管理线程好？"><a href="#为什么使用-Executor-框架比使用应用创建和管理线程好？" class="headerlink" title="为什么使用 Executor 框架比使用应用创建和管理线程好？"></a><strong>为什么使用 Executor 框架比使用应用创建和管理线程好？</strong></h1><p>为什么要使用 Executor 线程池框架每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源，直接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</p><p><strong>使用 Executor 线程池框架的优点</strong>：</p><ol><li>能复用已存在并空闲的线程从而减少线程对象的创建从而减少了消亡线程的开销。 </li><li>可有效控制最大并发线程数，提高系统资源使用率，同时避免过多资源竞争。 </li><li>框架中已经有定时、定期、单线程、并发数控制等功能。 </li><li>综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。</li></ol><h1 id="java-中有几种方法可以实现一个线程？"><a href="#java-中有几种方法可以实现一个线程？" class="headerlink" title="java 中有几种方法可以实现一个线程？"></a><strong>java 中有几种方法可以实现一个线程？</strong></h1><ol><li>继承 Thread 类 </li><li>实现 Runnable 接口 </li><li>实现 Callable 接口，需要实现的是 call() 方法</li></ol><h1 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a><strong>如何停止一个正在运行的线程？</strong></h1><h2 id="使用共享变量的方式"><a href="#使用共享变量的方式" class="headerlink" title="使用共享变量的方式"></a>使用共享变量的方式</h2><p>在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。</p><h2 id="使用-interrupt-方法终止线程"><a href="#使用-interrupt-方法终止线程" class="headerlink" title="使用 interrupt 方法终止线程"></a>使用 interrupt 方法终止线程</h2><p>如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用 Thread.join()方法，或者Thread.sleep() 方 法 ， 在网络中调用 ServerSocket.accept()方法 ， 或者调用了DatagramSocket.receive()方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为 true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。这里我们给出的建议是，不要使用 stop()方法，而是使用 Thread 提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。 </p><h1 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify()和 notifyAll()有什么区别？"></a><strong>notify()和 notifyAll()有什么区别？</strong></h1><p>当一个线程进入 wait 之后，就必须等其他线程 notify/notifyall,使用 notifyall,可以唤醒所有处于 wait 状态的线程，使其重新进入锁的争夺队列中，而 notify 只能唤醒一个。如果没把握，建议 notifyAll，防止 notigy 因为信号丢失而造成程序异常。</p><h1 id="什么是-Daemon-线程？它有什么意义？"><a href="#什么是-Daemon-线程？它有什么意义？" class="headerlink" title="什么是 Daemon 线程？它有什么意义？"></a><strong>什么是 Daemon 线程？它有什么意义？</strong></h1><p>所谓后台(daemon)线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。</p><p>反过来说， 只要有任何非后台线程还在运行，程序就不会终止。必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。注意：后台进程在不执行 finally 子句的情况下就会终止其 run()方法。</p><p>比如：JVM 的垃圾回收线程就是 Daemon 线程，Finalizer 也是守护线程。</p><h1 id="当一个线程进入某个对象的一个-synchronized-的实例方法后，其它线程是否可进入此对象的其它方法？"><a href="#当一个线程进入某个对象的一个-synchronized-的实例方法后，其它线程是否可进入此对象的其它方法？" class="headerlink" title="当一个线程进入某个对象的一个 synchronized 的实例方法后，其它线程是否可进入此对象的其它方法？"></a>当一个线程进入某个对象的一个 synchronized 的实例方法后，其它线程是否可进入此对象的其它方法？</h1><p>如果其他方法没有 synchronized 的话，其他线程是可以进入的。所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。</p><h1 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a><strong>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</strong></h1><p><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p><p><strong>乐观锁</strong>：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition 机制，其实都是提供的乐观锁。在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。 </p><blockquote><p><strong>乐观锁的实现方式</strong>：使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</p></blockquote><blockquote><p><strong>CAS 缺点</strong>： java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自动将该位置值更新为新值 B。否则处理器不做任何操作。</p></blockquote><blockquote><p><strong>ABA 问题</strong>：比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference来解决 ABA 问题。</p></blockquote><blockquote><p><strong>循环时间长开销大</strong>：对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的CPU 资源，效率低于 synchronized。</p></blockquote><blockquote><p><strong>只能保证一个共享变量的原子操作</strong>：当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p></blockquote><h1 id="SynchronizedMap-和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap 和 ConcurrentHashMap 有什么区别？"></a><strong>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</strong></h1><p>`SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map。</p><p>ConcurrentHashMap 使用分段锁来保证在多线程下的性能。ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。</p><p>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时new 新的数据从而不影响原有的数据 ，iterator 完成后再将头指针替换为新的数据 ，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p><h1 id="CopyOnWriteArrayList-可以用于什么应用场景？"><a href="#CopyOnWriteArrayList-可以用于什么应用场景？" class="headerlink" title="CopyOnWriteArrayList 可以用于什么应用场景？"></a><strong>CopyOnWriteArrayList 可以用于什么应用场景？</strong></h1><p>`CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在 CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p><p>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc；</p><p>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的,虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求； </p><blockquote><p><strong>CopyOnWriteArrayList 透露的思想</strong> ：</p><ol><li>读写分离，读和写分开 </li><li>最终一致性 </li><li>使用另外开辟空间的思路，来解决并发冲突</li></ol></blockquote><h1 id="什么叫线程安全？servlet-是线程安全吗"><a href="#什么叫线程安全？servlet-是线程安全吗" class="headerlink" title="什么叫线程安全？servlet 是线程安全吗?"></a><strong>什么叫线程安全？servlet 是线程安全吗?</strong></h1><p>线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p><p>Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。</p><p>Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一个新的 action分配给这个请求，请求完成后销毁。</p><p>SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多线程的问题。</p><h1 id="volatile-有什么用？能否用一句话说明下-volatile-的应用场景？"><a href="#volatile-有什么用？能否用一句话说明下-volatile-的应用场景？" class="headerlink" title="volatile 有什么用？能否用一句话说明下 volatile 的应用场景？"></a><strong>volatile 有什么用？能否用一句话说明下 volatile 的应用场</strong>景？</h1><p>volatile 保证内存可见性和禁止指令重排。volatile 用于多线程环境下的单次操作(单次读或者单次写)。</p><h1 id="为什么代码会重排序？"><a href="#为什么代码会重排序？" class="headerlink" title="为什么代码会重排序？"></a><strong>为什么代码会重排序？</strong></h1><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p><ol><li>在单线程环境下不能改变程序运行的结果； </li><li>存在数据依赖关系的不允许重排序需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</li></ol><h1 id="一个线程运行时发生异常会怎样？"><a href="#一个线程运行时发生异常会怎样？" class="headerlink" title="一个线程运行时发生异常会怎样？"></a><strong>一个线程运行时发生异常会怎样？</strong></h1><p>如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM 会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理。</p><h1 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a><strong>如何在两个线程间共享数据？</strong></h1><p>在两个线程间共享变量即可实现共享。一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。</p><h1 id="为什么-wait-notify-和-notifyAll-这些方法不在-thread-类里面？"><a href="#为什么-wait-notify-和-notifyAll-这些方法不在-thread-类里面？" class="headerlink" title="为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？"></a>为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？</h1><p>一个很明显的原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象。</p><h1 id="什么是-ThreadLocal-变量？"><a href="#什么是-ThreadLocal-变量？" class="headerlink" title="什么是 ThreadLocal 变量？"></a><strong>什么是 ThreadLocal 变量？</strong></h1><p>`ThreadLocal 是 Java 里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用 ThreadLocal 让 SimpleDateFormat 变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</p><h1 id="Java-中-interrupted-和-isInterrupted-方法的区别？"><a href="#Java-中-interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="Java 中 interrupted 和 isInterrupted 方法的区别？"></a><strong>Java 中 interrupted 和 isInterrupted 方法的区别？</strong></h1><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p>interrupt 方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出 interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p><h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted"></a>interrupted</h2><p>查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 <code>interrupted</code>则返回 <code>true</code>，第二次和后面的就返回 <code>false</code> 了。</p><h2 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted"></a>isInterrupted</h2><p>仅仅是查询当前线程的中断状态</p><h1 id="为什么-wait-和-notify-方法要在同步块中调用？"><a href="#为什么-wait-和-notify-方法要在同步块中调用？" class="headerlink" title="为什么 wait 和 notify 方法要在同步块中调用？"></a><strong>为什么 wait 和 notify 方法要在同步块中调用？</strong></h1><p>`Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。</p><h1 id="为什么你应该在循环中检查等待条件"><a href="#为什么你应该在循环中检查等待条件" class="headerlink" title="为什么你应该在循环中检查等待条件?"></a><strong>为什么你应该在循环中检查等待条件?</strong></h1><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p><h1 id="Java-中的同步集合与并发集合有什么区别？"><a href="#Java-中的同步集合与并发集合有什么区别？" class="headerlink" title="Java 中的同步集合与并发集合有什么区别？"></a><strong>Java 中的同步集合与并发集合有什么区别？</strong></h1><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5 介绍了并发集合像 ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p><h1 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a><strong>什么是线程池？</strong></h1><p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。如果每个请求都创建一个线程去处理，那么服务器的资源很快就会被耗尽，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p><h1 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a><strong>为什么要使用线程池？</strong></h1><p>创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。（我们可以把创建和销毁的线程的过程去掉）</p><h1 id="线程池有什么作用？"><a href="#线程池有什么作用？" class="headerlink" title="线程池有什么作用？"></a>线程池有什么作用？</h1><p>线程池作用就是限制系统中执行线程的数量。 </p><ol><li>提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。 </li><li>方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建 100 个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有 101 个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。</li></ol><h1 id="说说几种常见的线程池及使用场景"><a href="#说说几种常见的线程池及使用场景" class="headerlink" title="说说几种常见的线程池及使用场景"></a><strong>说说几种常见的线程池及使用场景</strong></h1><ol><li>newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li><li>newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。</li></ol><h1 id="线程池中的几种重要的参数"><a href="#线程池中的几种重要的参数" class="headerlink" title="线程池中的几种重要的参数"></a><strong>线程池中的几种重要的参数</strong></h1><ol><li>corePoolSize 就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收</li><li>maximumPoolSize 就是线程池中可以容纳的最大线程的数量</li><li>keepAliveTime，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中 ， 除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间</li><li>util，就是计算这个时间的一个单位。</li><li>workQueue，就是等待队列，任务可以储存在任务队列中等待被执行，执行的是 FIFIO 原则（先进先出）。</li><li>threadFactory，就是创建线程的线程工厂。</li><li>handler,是一种拒绝策略，我们可以在任务满了之后，拒绝执行某些任务。</li></ol><h1 id="说说线程池的拒绝策略"><a href="#说说线程池的拒绝策略" class="headerlink" title="说说线程池的拒绝策略"></a><strong>说说线程池的拒绝策略</strong></h1><p>当请求任务不断的过来，而系统此时又处理不过来的时候，我们需要采取的策略是拒绝服务。RejectedExecutionHandler 接口提供了拒绝任务处理的自定义方法的机会。在ThreadPoolExecutor 中已经包含四种处理策略。</p><ol><li>AbortPolicy 策略：该策略会直接抛出异常，阻止系统正常工作。</li><li>CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。</li><li>DiscardOleddestPolicy 策略： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</li><li>DiscardPolicy 策略：该策略默默的丢弃无法处理的任务，不予任何处理。 </li></ol><p>除了 JDK 默认提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，自定义的方式很简单，直接实现 RejectedExecutionHandler 接口即可。</p><h1 id="线程池都有哪几种工作队列"><a href="#线程池都有哪几种工作队列" class="headerlink" title="线程池都有哪几种工作队列"></a><strong>线程池都有哪几种工作队列</strong></h1><ol><li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li><li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按 FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool()使用了这个队列</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态 ，吞吐量 通常要高于 LinkedBlockingQueue ， 静态工厂方法Executors.newCachedThreadPool 使用了这个队列。 </li><li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li></ol><h1 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a><strong>怎么检测一个线程是否拥有锁？</strong></h1><p>在 java.lang.Thread 中有一个方法叫 holdsLock()，它返回 true 如果当且仅当当前线程拥有某个具体对象的锁。</p><h1 id="Thread-类中的-yield-方法有什么作用？"><a href="#Thread-类中的-yield-方法有什么作用？" class="headerlink" title="Thread 类中的 yield 方法有什么作用？"></a><strong>Thread 类中的 yield 方法有什么作用？</strong></h1><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。 </p><h1 id="Java-中-ConcurrentHashMap-的并发度是什么？"><a href="#Java-中-ConcurrentHashMap-的并发度是什么？" class="headerlink" title="Java 中 ConcurrentHashMap 的并发度是什么？"></a><strong>Java 中 ConcurrentHashMap 的并发度是什么？</strong></h1><p>`ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用。</p><p>在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现,利用 CAS算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。</p><h1 id="Java-中-Semaphore-是什么？"><a href="#Java-中-Semaphore-是什么？" class="headerlink" title="Java 中 Semaphore 是什么？"></a><strong>Java 中 Semaphore 是什么？</strong></h1><p>Java 中的 Semaphore 是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p><h1 id="Java-线程池中-submit-和-execute-方法有什么区别？"><a href="#Java-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="Java 线程池中 submit() 和 execute()方法有什么区别？"></a><strong>Java 线程池中 submit() 和 execute()方法有什么区别？</strong></h1><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是 void，它定义在 Executor 接口中。</p><p>而 submit()方法可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor都有这些方法。</p><h1 id="什么是阻塞式方法？"><a href="#什么是阻塞式方法？" class="headerlink" title="什么是阻塞式方法？"></a><strong>什么是阻塞式方法？</strong></h1><p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的 accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p><h1 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a><strong>volatile 变量和 atomic 变量有什么不同？</strong></h1><p>`Volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用 volatile 修饰 count 变量那么 count++ 操作就不是原子性的。</p><p>而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如 getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p><h1 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a><strong>你对线程优先级的理解是什么？</strong></h1><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int变量(从 1-10)，1 代表最低优先级，10 代表最高优先级。</p><p>java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纯CSS</title>
      <link href="/2021/07/15/%E7%BA%AFCSS%E7%9A%84%E5%8D%81%E4%BA%8C%E7%A7%8D/"/>
      <url>/2021/07/15/%E7%BA%AFCSS%E7%9A%84%E5%8D%81%E4%BA%8C%E7%A7%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="经典款"><a href="#经典款" class="headerlink" title="经典款"></a>经典款</h2><h3 id="HTML代码"><a href="#HTML代码" class="headerlink" title="HTML代码"></a>HTML代码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;classic-1&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;classic-2&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;classic-3&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;classic-4&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;classic-5&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;classic-6&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;classic-7&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;classic-8&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;classic-9&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;classic-10&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="CSS代码"><a href="#CSS代码" class="headerlink" title="CSS代码"></a>CSS代码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[class*=classic]:before &#123;</span><br><span class="line">    content:<span class="string">&quot;Loading...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.classic-1 &#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    font-family: sans-serif;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">    animation:c1 1s linear infinite alternate;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes c1 &#123;to&#123;opacity: 0&#125;&#125;</span><br><span class="line"></span><br><span class="line">.classic-2 &#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    font-family: sans-serif;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">    padding-bottom: 8px;</span><br><span class="line">    background:linear-gradient(currentColor 0 0) bottom left/0% 3px no-repeat;</span><br><span class="line">    animation:c2 2s linear infinite;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes c2 &#123;to&#123;background-size: 100% 3px&#125;&#125;</span><br><span class="line"></span><br><span class="line">.classic-3 &#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    font-family: sans-serif;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">    padding:0 5px 8px 0;</span><br><span class="line">    background:repeating-linear-gradient(90deg,currentColor 0 8%,<span class="comment">#0000 0 10%) 200% 100%/200% 3px no-repeat;</span></span><br><span class="line">    animation:c3 2s steps(6) infinite;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes c3 &#123;to&#123;background-position: 80% 100%&#125;&#125;</span><br><span class="line"></span><br><span class="line">.classic-4 &#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    font-family: monospace;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">    clip-path: inset(0 3ch 0 0);</span><br><span class="line">    animation:c4 1s steps(4) infinite;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes c4 &#123;to&#123;clip-path: inset(0 -1ch 0 0)&#125;&#125;</span><br><span class="line"></span><br><span class="line">.classic-5 &#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    font-family: monospace;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">    clip-path: inset(0 100% 0 0);</span><br><span class="line">    animation:c5 2s steps(11) infinite;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes c5 &#123;to&#123;clip-path: inset(0 -1ch 0 0)&#125;&#125;</span><br><span class="line"></span><br><span class="line">.classic-6 &#123;</span><br><span class="line">    --c:<span class="comment">#000;</span></span><br><span class="line">    font-weight: bold;</span><br><span class="line">    font-family: monospace;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">    color:<span class="comment">#0000;</span></span><br><span class="line">    overflow:hidden;</span><br><span class="line">    text-shadow:0 0 var(--c),11ch 0 var(--c);</span><br><span class="line">    animation:c6 2s infinite linear;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes c6 &#123;to&#123;text-shadow:-11ch 0 var(--c),0ch 0 var(--c)&#125;&#125;</span><br><span class="line"></span><br><span class="line">.classic-7 &#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    font-family: monospace;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">    color:<span class="comment">#0000;</span></span><br><span class="line">    background:linear-gradient(90deg,red calc(50% + 0.5ch),<span class="comment">#000 0) right/calc(200% + 1ch) 100%;</span></span><br><span class="line">    -webkit-background-clip:text;</span><br><span class="line">    background-clip:text;</span><br><span class="line">    animation:c7 2s infinite steps(11);</span><br><span class="line">&#125;</span><br><span class="line">@keyframes c7 &#123;to&#123;background-position: left&#125;&#125;</span><br><span class="line"></span><br><span class="line">.classic-8 &#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    font-family: monospace;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">    color:<span class="comment">#0000;</span></span><br><span class="line">    background:linear-gradient(90deg,<span class="comment">#000 calc(50% - 0.5ch),red 0 calc(50% + 0.5ch),#000 0) right/calc(200% + 1ch) 100%;</span></span><br><span class="line">    -webkit-background-clip:text;</span><br><span class="line">    background-clip:text;</span><br><span class="line">    animation:c8 2s infinite steps(11);</span><br><span class="line">&#125;</span><br><span class="line">@keyframes c8 &#123;to&#123;background-position: left&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.classic-9 &#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    font-family: monospace;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">    color:<span class="comment">#0000;</span></span><br><span class="line">    overflow:hidden;</span><br><span class="line">    text-shadow:0 0 <span class="comment">#000,11ch 0 green,22ch 0 red,33ch 0 blue,44ch 0 #000;</span></span><br><span class="line">    animation:c9 5s infinite cubic-bezier(0.3,1,0,1);</span><br><span class="line">&#125;</span><br><span class="line">@keyframes c9 &#123;</span><br><span class="line">    25% &#123;text-shadow:-11ch 0 <span class="comment">#000,  0ch 0 green, 11ch 0 red, 22ch 0 blue,33ch 0 #000&#125;</span></span><br><span class="line">    50% &#123;text-shadow:-22ch 0 <span class="comment">#000,-11ch 0 green,  0ch 0 red, 11ch 0 blue,22ch 0 #000&#125;</span></span><br><span class="line">    75% &#123;text-shadow:-33ch 0 <span class="comment">#000,-22ch 0 green,-11ch 0 red,  0ch 0 blue,11ch 0 #000&#125;</span></span><br><span class="line">    100%&#123;text-shadow:-44ch 0 <span class="comment">#000,-33ch 0 green,-22ch 0 red,-11ch 0 blue, 0ch 0 #000&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.classic-10 &#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    font-family: monospace;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">    color:<span class="comment">#0000;</span></span><br><span class="line">    background: linear-gradient(90deg,<span class="comment">#000 25%,green 0 50%,red 0 75%,blue 0) 0 0/400% 100%;</span></span><br><span class="line">    -webkit-background-clip:text;</span><br><span class="line">    background-clip:text;</span><br><span class="line">    animation:c10 5s infinite cubic-bezier(0.3,1,0,1);</span><br><span class="line">&#125;</span><br><span class="line">@keyframes c10 &#123;</span><br><span class="line">    25% &#123;background-position: calc(1*100%/3) 0&#125;</span><br><span class="line">    50% &#123;background-position: calc(2*100%/3) 0&#125;</span><br><span class="line">    75% &#123;background-position: calc(3*100%/3) 0&#125;</span><br><span class="line">    100%&#123;background-position: calc(4*100%/3) 0&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**/</span><br><span class="line">body &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-columns: repeat(auto-fit,minmax(250px,1fr));</span><br><span class="line">    grid-auto-rows: 130px;</span><br><span class="line">    place-items:center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="啦啦啦啦啦啦"><a href="#啦啦啦啦啦啦" class="headerlink" title="啦啦啦啦啦啦"></a>啦啦啦啦啦啦</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 暂无内容</span><br></pre></td></tr></table></figure><h3 id="啦啦啦啦啦啦-1"><a href="#啦啦啦啦啦啦-1" class="headerlink" title="啦啦啦啦啦啦"></a>啦啦啦啦啦啦</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 暂无内容</span><br></pre></td></tr></table></figure><h3 id="啦啦啦啦啦啦-2"><a href="#啦啦啦啦啦啦-2" class="headerlink" title="啦啦啦啦啦啦"></a>啦啦啦啦啦啦</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 暂无内容</span><br></pre></td></tr></table></figure><h3 id="啦啦啦啦啦啦-3"><a href="#啦啦啦啦啦啦-3" class="headerlink" title="啦啦啦啦啦啦"></a>啦啦啦啦啦啦</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 暂无内容</span><br></pre></td></tr></table></figure><h3 id="啦啦啦啦啦啦-4"><a href="#啦啦啦啦啦啦-4" class="headerlink" title="啦啦啦啦啦啦"></a>啦啦啦啦啦啦</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 暂无内容</span><br></pre></td></tr></table></figure><h3 id="啦啦啦啦啦啦-5"><a href="#啦啦啦啦啦啦-5" class="headerlink" title="啦啦啦啦啦啦"></a>啦啦啦啦啦啦</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 暂无内容</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS哈哈哈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛子牛子牛子</title>
      <link href="/2021/07/15/%E7%89%9B%E5%AD%90%E7%89%9B%E5%AD%90/"/>
      <url>/2021/07/15/%E7%89%9B%E5%AD%90%E7%89%9B%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      
        <tags>
            
            <tag> 牛子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ 实战教程</title>
      <link href="/2021/07/12/RibbitMQ%20%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/"/>
      <url>/2021/07/12/RibbitMQ%20%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="RabbitMQ-实战教程"><a href="#RabbitMQ-实战教程" class="headerlink" title="RabbitMQ 实战教程"></a>RabbitMQ 实战教程</h1><h2 id="1-MQ引言"><a href="#1-MQ引言" class="headerlink" title="1.MQ引言"></a>1.MQ引言</h2><h3 id="1-1-什么是MQ"><a href="#1-1-什么是MQ" class="headerlink" title="1.1 什么是MQ"></a>1.1 什么是MQ</h3><p><code>MQ</code>(Message Quene) :  翻译为 <code>消息队列</code>,通过典型的 <code>生产者</code>和<code>消费者</code>模型,生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入,轻松的实现系统间解耦。别名为 <code>消息中间件</code>    通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</p><h3 id="1-2-MQ有哪些"><a href="#1-2-MQ有哪些" class="headerlink" title="1.2 MQ有哪些"></a>1.2 MQ有哪些</h3><p>当今市面上有很多主流的消息中间件，如老牌的<code>ActiveMQ</code>、<code>RabbitMQ</code>，炙手可热的<code>Kafka</code>，阿里巴巴自主开发<code>RocketMQ</code>等。</p><h3 id="1-3-不同MQ特点"><a href="#1-3-不同MQ特点" class="headerlink" title="1.3 不同MQ特点"></a>1.3 不同MQ特点</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.ActiveMQ</span></span><br><span class="line"><span class="code">ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件,在中小型企业颇受欢迎!</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.Kafka</span></span><br><span class="line"><span class="code">Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，</span></span><br><span class="line"><span class="code">追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，</span></span><br><span class="line"><span class="code">适合产生大量数据的互联网服务的数据收集业务。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.RocketMQ</span></span><br><span class="line"><span class="code">RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起</span></span><br><span class="line"><span class="code">源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消</span></span><br><span class="line"><span class="code">息推送、日志流式处理、binglog分发等场景。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.RabbitMQ</span></span><br><span class="line"><span class="code">RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和</span></span><br><span class="line"><span class="code">发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在</span></span><br><span class="line"><span class="code">其次。</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure><blockquote><p>RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。</p></blockquote><hr><h2 id="2-RabbitMQ-的引言"><a href="#2-RabbitMQ-的引言" class="headerlink" title="2.RabbitMQ 的引言"></a>2.RabbitMQ 的引言</h2><h3 id="2-1-RabbitMQ"><a href="#2-1-RabbitMQ" class="headerlink" title="2.1 RabbitMQ"></a>2.1 RabbitMQ</h3><blockquote><p>基于<code>AMQP</code>协议，erlang语言开发，是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一。</p></blockquote><p>![image-20190925215603036](RibbitMQ 实战教程.assets/image-20190925215603036-9419777.png)</p><p><code>官网</code>: <a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><p><code>官方教程</code>: <a href="https://www.rabbitmq.com/#getstarted">https://www.rabbitmq.com/#getstarted</a></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># AMQP 协议</span></span><br><span class="line"><span class="code">AMQP（advanced message queuing protocol）`在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是AMQP协议模型:</span></span><br></pre></td></tr></table></figure><p>![image-20200311182438041](RibbitMQ 实战教程.assets/image-20200311182438041.png)</p><h3 id="2-2-RabbitMQ-的安装"><a href="#2-2-RabbitMQ-的安装" class="headerlink" title="2.2 RabbitMQ 的安装"></a>2.2 RabbitMQ 的安装</h3><h4 id="2-2-1-下载"><a href="#2-2-1-下载" class="headerlink" title="2.2.1 下载"></a>2.2.1 下载</h4><p><code>官网下载地址</code>: <a href="https://www.rabbitmq.com/download.html![image-20190925220115235]">https://www.rabbitmq.com/download.html![image-20190925220115235]</a>(RibbitMQ 实战教程.assets/image-20190925220115235.png)</p><blockquote><p><code>最新版本</code>: 3.7.18</p></blockquote><h4 id="2-2-2-下载的安装包-image-20190925220343521-RibbitMQ-实战教程-assets-image-20190925220343521-png"><a href="#2-2-2-下载的安装包-image-20190925220343521-RibbitMQ-实战教程-assets-image-20190925220343521-png" class="headerlink" title="2.2.2 下载的安装包![image-20190925220343521](RibbitMQ 实战教程.assets/image-20190925220343521.png)"></a>2.2.2 下载的安装包![image-20190925220343521](RibbitMQ 实战教程.assets/image-20190925220343521.png)</h4><blockquote><p><code>注意</code>:这里的安装包是centos7安装的包</p></blockquote><h4 id="2-2-3-安装步骤"><a href="#2-2-3-安装步骤" class="headerlink" title="2.2.3 安装步骤"></a>2.2.3 安装步骤</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.将rabbitmq安装包上传到linux系统中</span></span><br><span class="line"><span class="code">erlang-22.0.7-1.el7.x86_64.rpm</span></span><br><span class="line"><span class="code">rabbitmq-server-3.7.18-1.el7.noarch.rpm</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.安装Erlang依赖包</span></span><br><span class="line"><span class="code">rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.安装RabbitMQ安装包(需要联网)</span></span><br><span class="line"><span class="code">yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm</span></span><br><span class="line"><span class="code">注意:默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,需要</span></span><br><span class="line"><span class="code">将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config</span></span><br><span class="line"><span class="code"># 4.复制配置文件</span></span><br><span class="line"><span class="code">cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.查看配置文件位置</span></span><br><span class="line"><span class="code">ls /etc/rabbitmq/rabbitmq.config</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.修改配置文件(参见下图:)</span></span><br><span class="line"><span class="code">vim /etc/rabbitmq/rabbitmq.config </span></span><br></pre></td></tr></table></figure><p>![image-20190925222230260](RibbitMQ 实战教程.assets/image-20190925222230260-3836271.png)</p><p>将上图中配置文件中红色部分去掉<code>%%</code>,以及最后的<code>,</code>逗号 修改为下图:</p><p>![image-20190925222329200](RibbitMQ 实战教程.assets/image-20190925222329200-3836312.png)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.执行如下命令,启动rabbitmq中的插件管理</span></span><br><span class="line"><span class="code">rabbitmq-plugins enable rabbitmq_management</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">出现如下说明:</span></span><br><span class="line"><span class="code">Enabling plugins on node rabbit@localhost:</span></span><br><span class="line"><span class="code">    rabbitmq_management</span></span><br><span class="line"><span class="code">    The following plugins have been configured:</span></span><br><span class="line"><span class="code">      rabbitmq_management</span></span><br><span class="line"><span class="code">      rabbitmq_management_agent</span></span><br><span class="line"><span class="code">      rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code">    Applying plugin configuration to rabbit@localhost...</span></span><br><span class="line"><span class="code">    The following plugins have been enabled:</span></span><br><span class="line"><span class="code">      rabbitmq_management</span></span><br><span class="line"><span class="code">      rabbitmq_management_agent</span></span><br><span class="line"><span class="code">      rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    set 3 plugins.</span></span><br><span class="line"><span class="code">    Offline change; changes will take effect at broker restart.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 8.启动RabbitMQ的服务</span></span><br><span class="line"><span class="code">systemctl start rabbitmq-server</span></span><br><span class="line"><span class="code">systemctl restart rabbitmq-server</span></span><br><span class="line"><span class="code">systemctl stop rabbitmq-server</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 9.查看服务状态(见下图:)</span></span><br><span class="line"><span class="code">systemctl status rabbitmq-server</span></span><br><span class="line"><span class="code">  ● rabbitmq-server.service - RabbitMQ broker</span></span><br><span class="line"><span class="code">     Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)</span></span><br><span class="line"><span class="code">     Active: active (running) since 三 2019-09-25 22:26:35 CST; 7s ago</span></span><br><span class="line"><span class="code">   Main PID: 2904 (beam.smp)</span></span><br><span class="line"><span class="code">     Status: &quot;Initialized&quot;</span></span><br><span class="line"><span class="code">     CGroup: /system.slice/rabbitmq-server.service</span></span><br><span class="line"><span class="code">             ├─2904 /usr/lib64/erlang/erts-10.4.4/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -</span></span><br><span class="line"><span class="code">             MBlmbcs...</span></span><br><span class="line"><span class="code">             ├─3220 erl_child_setup 32768</span></span><br><span class="line"><span class="code">             ├─3243 inet_gethost 4</span></span><br><span class="line"><span class="code">             └─3244 inet_gethost 4</span></span><br><span class="line"><span class="code">      .........</span></span><br></pre></td></tr></table></figure><p>![image-20190925222743776](RibbitMQ 实战教程.assets/image-20190925222743776-3836511.png)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 10.关闭防火墙服务</span></span><br><span class="line"><span class="code">systemctl disable firewalld</span></span><br><span class="line"><span class="code">    Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.</span></span><br><span class="line"><span class="code">    Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span></span><br><span class="line"><span class="code">systemctl stop firewalld   </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 11.访问web管理界面</span></span><br><span class="line"><span class="code">http://10.15.0.8:15672/</span></span><br></pre></td></tr></table></figure><p> ![image-20190926194738708](RibbitMQ 实战教程.assets/image-20190926194738708-3836601.png)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 12.登录管理界面</span></span><br><span class="line"><span class="code">username:  guest</span></span><br><span class="line"><span class="code">password:  guest</span></span><br></pre></td></tr></table></figure><p>![image-20190926194954822](RibbitMQ 实战教程.assets/image-20190926194954822-3836665.png)</p><hr><h2 id="3-RabiitMQ-配置"><a href="#3-RabiitMQ-配置" class="headerlink" title="3. RabiitMQ 配置"></a>3. RabiitMQ 配置</h2><h3 id="3-1RabbitMQ-管理命令行"><a href="#3-1RabbitMQ-管理命令行" class="headerlink" title="3.1RabbitMQ 管理命令行"></a>3.1RabbitMQ 管理命令行</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.服务启动相关</span></span><br><span class="line"><span class="code">systemctl start|restart|stop|status rabbitmq-server</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.管理命令行  用来在不使用web管理界面情况下命令操作RabbitMQ</span></span><br><span class="line"><span class="code">rabbitmqctl  help  可以查看更多命令</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.插件管理命令行</span></span><br><span class="line"><span class="code">rabbitmq-plugins enable|list|disable </span></span><br></pre></td></tr></table></figure><h3 id="3-2-web管理界面介绍"><a href="#3-2-web管理界面介绍" class="headerlink" title="3.2 web管理界面介绍"></a>3.2 web管理界面介绍</h3><h4 id="3-2-1-overview概览"><a href="#3-2-1-overview概览" class="headerlink" title="3.2.1 overview概览"></a>3.2.1 overview概览</h4><p>![image-20191126162026720](RibbitMQ 实战教程.assets/image-20191126162026720.png)</p><ul><li><p><code>connections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况</code></p></li><li><p><code>channels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。</code></p></li><li><p><code>Exchanges：交换机，用来实现消息的路由</code></p></li><li><p><code>Queues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。</code></p></li></ul><h4 id="3-2-2-Admin用户和虚拟主机管理"><a href="#3-2-2-Admin用户和虚拟主机管理" class="headerlink" title="3.2.2 Admin用户和虚拟主机管理"></a>3.2.2 Admin用户和虚拟主机管理</h4><h5 id="1-添加用户"><a href="#1-添加用户" class="headerlink" title="1. 添加用户"></a>1. 添加用户</h5><p>![image-20191126162617280](RibbitMQ 实战教程.assets/image-20191126162617280.png)</p><p>上面的Tags选项，其实是指定用户的角色，可选的有以下几个：</p><ul><li><p><code>超级管理员(administrator)</code></p><p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p></li><li><p><code>监控者(monitoring)</code></p><p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p></li><li><p><code>策略制定者(policymaker)</code></p><p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p></li><li><p><code>普通管理者(management)</code></p><p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p></li><li><p><code>其他</code></p><p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p></li></ul><h5 id="2-创建虚拟主机"><a href="#2-创建虚拟主机" class="headerlink" title="2. 创建虚拟主机"></a>2. 创建虚拟主机</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 虚拟主机</span></span><br><span class="line"><span class="code">为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。</span></span><br></pre></td></tr></table></figure><p> ![image-20191126163023153](RibbitMQ 实战教程.assets/image-20191126163023153.png)</p><h5 id="3-绑定虚拟主机和用户"><a href="#3-绑定虚拟主机和用户" class="headerlink" title="3. 绑定虚拟主机和用户"></a>3. 绑定虚拟主机和用户</h5><p>创建好虚拟主机，我们还要给用户添加访问权限：</p><p>点击添加好的虚拟主机：</p><p> ![image-20191126163506795](RibbitMQ 实战教程.assets/image-20191126163506795.png)</p><p>进入虚拟机设置界面:</p><p>![image-20191126163631889](RibbitMQ 实战教程.assets/image-20191126163631889.png)</p><hr><h2 id="4-RabbitMQ-的第一个程序"><a href="#4-RabbitMQ-的第一个程序" class="headerlink" title="4.RabbitMQ 的第一个程序"></a>4.RabbitMQ 的第一个程序</h2><h3 id="4-0-AMQP协议的回顾"><a href="#4-0-AMQP协议的回顾" class="headerlink" title="4.0 AMQP协议的回顾"></a>4.0 AMQP协议的回顾</h3><p>![image-20200312140114784](RibbitMQ 实战教程.assets/image-20200312140114784.png)</p><h3 id="4-1-RabbitMQ支持的消息模型"><a href="#4-1-RabbitMQ支持的消息模型" class="headerlink" title="4.1 RabbitMQ支持的消息模型"></a>4.1 RabbitMQ支持的消息模型</h3><p>![image-20191126165434784](RibbitMQ 实战教程.assets/image-20191126165434784.png)</p><p>![image-20191126165459282](RibbitMQ 实战教程.assets/image-20191126165459282.png)</p><h3 id="4-2-引入依赖"><a href="#4-2-引入依赖" class="headerlink" title="4.2 引入依赖"></a>4.2 引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-第一种模型-直连"><a href="#4-3-第一种模型-直连" class="headerlink" title="4.3 第一种模型(直连)"></a>4.3 第一种模型(直连)</h3><p>![image-20191126165840602](RibbitMQ 实战教程.assets/image-20191126165840602.png)</p><p>在上图的模型中，有以下概念：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来。</li><li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li></ul><h5 id="1-开发生产者"><a href="#1-开发生产者" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;10.15.0.9&quot;</span>);</span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;ems&quot;</span>);</span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line"><span class="comment">//创建通道</span></span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"><span class="comment">//参数1: 是否持久化  参数2:是否独占队列 参数3:是否自动删除  参数4:其他属性</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;hello&quot;</span>, <span class="keyword">null</span>,<span class="string">&quot;hello rabbitmq&quot;</span>.getBytes());</span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><h5 id="2-开发消费者"><a href="#2-开发消费者" class="headerlink" title="2. 开发消费者"></a>2. 开发消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;10.15.0.9&quot;</span>);</span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;ems&quot;</span>);</span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.basicConsume(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="3-参数的说明"><a href="#3-参数的说明" class="headerlink" title="3. 参数的说明"></a>3. 参数的说明</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="string">&#x27;参数1&#x27;</span>:用来声明通道对应的队列</span><br><span class="line"> <span class="string">&#x27;参数2&#x27;</span>:用来指定是否持久化队列</span><br><span class="line"> <span class="string">&#x27;参数3&#x27;</span>:用来指定是否独占队列</span><br><span class="line"> <span class="string">&#x27;参数4&#x27;</span>:用来指定是否自动删除队列</span><br><span class="line"> <span class="string">&#x27;参数5&#x27;</span>:对队列的额外配置</span><br></pre></td></tr></table></figure><hr><h3 id="4-4-第二种模型-work-quene"><a href="#4-4-第二种模型-work-quene" class="headerlink" title="4.4 第二种模型(work quene)"></a>4.4 第二种模型(work quene)</h3><p><code>Work queues</code>，也被称为（<code>Task queues</code>），任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。</p><p>![image-20200314221002008](RibbitMQ 实战教程.assets/image-20200314221002008.png)</p><p>角色：</p><ul><li>P：生产者：任务的发布者</li><li>C1：消费者-1，领取任务并且完成任务，假设完成速度较慢</li><li>C2：消费者-2：领取任务并完成任务，假设完成速度快</li></ul><h5 id="1-开发生产者-1"><a href="#1-开发生产者-1" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="keyword">null</span>, (i+<span class="string">&quot;====&gt;:我是消息&quot;</span>).getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-开发消费者-1"><a href="#2-开发消费者-1" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">channel.basicConsume(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="3-开发消费者-2"><a href="#3-开发消费者-2" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">channel.basicConsume(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);   <span class="comment">//处理消息比较慢 一秒处理一个消息</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2: &quot;</span>+<span class="keyword">new</span> String(body));  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4.测试结果"></a>4.测试结果</h5><p>![image-20200314223242058](RibbitMQ 实战教程.assets/image-20200314223242058.png)</p><p>![image-20200314223302207](RibbitMQ 实战教程.assets/image-20200314223302207.png)</p><blockquote><p><code>总结:默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环。</code></p></blockquote><h5 id="5-消息自动确认机制"><a href="#5-消息自动确认机制" class="headerlink" title="5.消息自动确认机制"></a>5.消息自动确认机制</h5><blockquote><p>Doing a task can take a few seconds. You may wonder what happens if one of the consumers starts a long task and dies with it only partly done. With our current code, once RabbitMQ delivers a message to the consumer it immediately marks it for deletion. In this case, if you kill a worker we will lose the message it was just processing. We’ll also lose all the messages that were dispatched to this particular worker but were not yet handled.</p><p>But we don’t want to lose any tasks. If a worker dies, we’d like the task to be delivered to another worker.</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);<span class="comment">//一次只接受一条未确认的消息</span></span><br><span class="line"><span class="comment">//参数2:关闭自动确认消息</span></span><br><span class="line">channel.basicConsume(<span class="string">&quot;hello&quot;</span>,<span class="keyword">false</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动确认消息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>设置通道一次只能消费一个消息</p></li><li><p>关闭消息的自动确认,开启手动确认消息</p><p>![image-20200314230412178](RibbitMQ 实战教程.assets/image-20200314230412178.png)</p><p>![image-20200314230423280](RibbitMQ 实战教程.assets/image-20200314230423280.png)</p></li></ul><hr><h3 id="4-5-第三种模型-fanout"><a href="#4-5-第三种模型-fanout" class="headerlink" title="4.5 第三种模型(fanout)"></a>4.5 第三种模型(fanout)</h3><p><code>fanout 扇出 也称为广播</code></p><p> ![image-20191126213115873](RibbitMQ 实战教程.assets/image-20191126213115873.png)</p><p>在广播模式下，消息发送流程是这样的：</p><ul><li> 可以有多个消费者</li><li> 每个<strong>消费者有自己的queue</strong>（队列）</li><li> 每个<strong>队列都要绑定到Exchange</strong>（交换机）</li><li><strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li><li> 交换机把消息发送给绑定过的所有队列</li><li> 队列的消费者都能拿到消息。实现一条消息被多个消费者消费</li></ul><h5 id="1-开发生产者-2"><a href="#1-开发生产者-2" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;fanout&quot;</span>);<span class="comment">//广播 一条消息多个消费者同时消费</span></span><br><span class="line"><span class="comment">//发布消息</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;hello&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><h5 id="2-开发消费者-1-1"><a href="#2-开发消费者-1-1" class="headerlink" title="2. 开发消费者-1"></a>2. 开发消费者-1</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绑定交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//将临时队列绑定exchange</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//处理消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="3-开发消费者-2-1"><a href="#3-开发消费者-2-1" class="headerlink" title="3. 开发消费者-2"></a>3. 开发消费者-2</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绑定交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//将临时队列绑定exchange</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//处理消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="4-开发消费者-3"><a href="#4-开发消费者-3" class="headerlink" title="4.开发消费者-3"></a>4.开发消费者-3</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绑定交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//将临时队列绑定exchange</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//处理消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者3: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="5-测试结果"><a href="#5-测试结果" class="headerlink" title="5. 测试结果"></a>5. 测试结果</h5><p>![image-20200315180653207](RibbitMQ 实战教程.assets/image-20200315180653207.png)</p><p>![image-20200315180708489](RibbitMQ 实战教程.assets/image-20200315180708489.png)</p><p>![image-20200315180728035](RibbitMQ 实战教程.assets/image-20200315180728035.png)</p><hr><h3 id="4-6-第四种模型-Routing"><a href="#4-6-第四种模型-Routing" class="headerlink" title="4.6 第四种模型(Routing)"></a>4.6 第四种模型(Routing)</h3><h4 id="4-6-1-Routing-之订阅模型-Direct-直连"><a href="#4-6-1-Routing-之订阅模型-Direct-直连" class="headerlink" title="4.6.1 Routing 之订阅模型-Direct(直连)"></a>4.6.1 Routing 之订阅模型-Direct(直连)</h4><p><code>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</code></p><p> 在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p>流程:</p><p>![image-20191126220145375](RibbitMQ 实战教程.assets/image-20191126220145375.png)</p><p>图解：</p><ul><li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li><li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li><li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</li><li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</li></ul><h5 id="1-开发生产者-3"><a href="#1-开发生产者-3" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明交换机  参数1:交换机名称 参数2:交换机类型 基于指令的Routing key转发</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//发布消息</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;logs_direct&quot;</span>,key,<span class="keyword">null</span>,(<span class="string">&quot;指定的route key&quot;</span>+key+<span class="string">&quot;的消息&quot;</span>).getBytes());</span><br></pre></td></tr></table></figure><h5 id="2-开发消费者-1-2"><a href="#2-开发消费者-1-2" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//声明交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//绑定队列和交换机</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;info&quot;</span>);</span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;warn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="3-开发消费者-2-2"><a href="#3-开发消费者-2-2" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//绑定队列和交换机</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;error&quot;</span>);</span><br><span class="line"><span class="comment">//消费消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="4-测试生产者发送Route-key为error的消息时"><a href="#4-测试生产者发送Route-key为error的消息时" class="headerlink" title="4.测试生产者发送Route key为error的消息时"></a>4.测试生产者发送Route key为error的消息时</h5><p> ![image-20200316102613933](RibbitMQ 实战教程.assets/image-20200316102613933.png)</p><p> ![image-20200316102627912](RibbitMQ 实战教程.assets/image-20200316102627912.png)</p><h5 id="5-测试生产者发送Route-key为info的消息时"><a href="#5-测试生产者发送Route-key为info的消息时" class="headerlink" title="5.测试生产者发送Route key为info的消息时"></a>5.测试生产者发送Route key为info的消息时</h5><p> ![image-20200316102925740](RibbitMQ 实战教程.assets/image-20200316102925740.png)</p><p> ![image-20200316102947326](RibbitMQ 实战教程.assets/image-20200316102947326.png)</p><hr><h4 id="4-6-2-Routing-之订阅模型-Topic"><a href="#4-6-2-Routing-之订阅模型-Topic" class="headerlink" title="4.6.2 Routing 之订阅模型-Topic"></a>4.6.2 Routing 之订阅模型-Topic</h4><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！这种模型<code>Routingkey</code> 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p>![image-20191127121900255](RibbitMQ 实战教程.assets/image-20191127121900255.png)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 统配符</span></span><br><span class="line"><span class="bullet">*</span> (star) can substitute for exactly one word.    匹配不多不少恰好1个词</span><br><span class="line"><span class="code"># (hash) can substitute for zero or more words.  匹配一个或多个词</span></span><br><span class="line"><span class="code"># 如:</span></span><br><span class="line"><span class="code">audit.#    匹配audit.irs.corporate或者 audit.irs 等</span></span><br><span class="line"><span class="code">    audit.*   只能匹配 audit.irs</span></span><br></pre></td></tr></table></figure><h5 id="1-开发生产者-4"><a href="#1-开发生产者-4" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生命交换机和交换机类型 topic 使用动态路由(通配符方式)</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;topics&quot;</span>,<span class="string">&quot;topic&quot;</span>);</span><br><span class="line">String routekey = <span class="string">&quot;user.save&quot;</span>;<span class="comment">//动态路由key</span></span><br><span class="line"><span class="comment">//发布消息</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;topics&quot;</span>,routekey,<span class="keyword">null</span>,(<span class="string">&quot;这是路由中的动态订阅模型,route key: [&quot;</span>+routekey+<span class="string">&quot;]&quot;</span>).getBytes());</span><br></pre></td></tr></table></figure><h5 id="2-开发消费者-1-3"><a href="#2-开发消费者-1-3" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h5><p><code>Routing Key中使用*通配符方式</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//声明交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;topics&quot;</span>,<span class="string">&quot;topic&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//绑定队列与交换机并设置获取交换机中动态路由</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;topics&quot;</span>,<span class="string">&quot;user.*&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="3-开发消费者-2-3"><a href="#3-开发消费者-2-3" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h5><p><code>Routing Key中使用#通配符方式</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;topics&quot;</span>,<span class="string">&quot;topic&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//绑定队列与交换机并设置获取交换机中动态路由</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;topics&quot;</span>,<span class="string">&quot;user.#&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="4-测试结果-1"><a href="#4-测试结果-1" class="headerlink" title="4.测试结果"></a>4.测试结果</h5><p> ![image-20200316113935785](RibbitMQ 实战教程.assets/image-20200316113935785.png)</p><p> ![image-20200316114000459](RibbitMQ 实战教程.assets/image-20200316114000459.png)</p><h2 id="5-SpringBoot中使用RabbitMQ"><a href="#5-SpringBoot中使用RabbitMQ" class="headerlink" title="5. SpringBoot中使用RabbitMQ"></a>5. SpringBoot中使用RabbitMQ</h2><h3 id="5-0-搭建初始环境"><a href="#5-0-搭建初始环境" class="headerlink" title="5.0 搭建初始环境"></a>5.0 搭建初始环境</h3><h5 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-配置配置文件"><a href="#2-配置配置文件" class="headerlink" title="2. 配置配置文件"></a>2. 配置配置文件</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springboot_rabbitmq</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">10.15</span><span class="number">.0</span><span class="number">.9</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">ems</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/ems</span></span><br></pre></td></tr></table></figure><p><code>RabbitTemplate</code>  用来简化操作     使用时候直接在项目中注入即可使用</p><h3 id="5-1-第一种hello-world模型使用"><a href="#5-1-第一种hello-world模型使用" class="headerlink" title="5.1 第一种hello world模型使用"></a>5.1 第一种hello world模型使用</h3><ol><li><h5 id="开发生产者"><a href="#开发生产者" class="headerlink" title="开发生产者"></a>开发生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="开发消费者"><a href="#开发消费者" class="headerlink" title="开发消费者"></a>开发消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;hello&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCustomer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-2-第二种work模型使用"><a href="#5-2-第二种work模型使用" class="headerlink" title="5.2 第二种work模型使用"></a>5.2 第二种work模型使用</h3><ol><li><h5 id="开发生产者-1"><a href="#开发生产者-1" class="headerlink" title="开发生产者"></a>开发生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;work&quot;</span>,<span class="string">&quot;hello work!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="开发消费者-1"><a href="#开发消费者-1" class="headerlink" title="开发消费者"></a>开发消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkCustomer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work message1 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work message2 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>说明:默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要额外配置</code></p></blockquote></li></ol><h3 id="5-3-Fanout-广播模型"><a href="#5-3-Fanout-广播模型" class="headerlink" title="5.3 Fanout 广播模型"></a>5.3 Fanout 广播模型</h3><ol><li><h5 id="开发生产者-2"><a href="#开发生产者-2" class="headerlink" title="开发生产者"></a>开发生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFanout</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;这是日志广播&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="开发消费者-2"><a href="#开发消费者-2" class="headerlink" title="开发消费者"></a>开发消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutCustomer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue,</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name=&quot;logs&quot;,type = &quot;fanout&quot;)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message1 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue, //创建临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name=&quot;logs&quot;,type = &quot;fanout&quot;)  //绑定交换机类型</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message2 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-4-Route-路由模型"><a href="#5-4-Route-路由模型" class="headerlink" title="5.4 Route 路由模型"></a>5.4 Route 路由模型</h3><ol><li><h5 id="开发生产者-3"><a href="#开发生产者-3" class="headerlink" title="开发生产者"></a>开发生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;directs&quot;</span>,<span class="string">&quot;error&quot;</span>,<span class="string">&quot;error 的日志信息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="开发消费者-3"><a href="#开发消费者-3" class="headerlink" title="开发消费者"></a>开发消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectCustomer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings =&#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue(),</span></span><br><span class="line"><span class="meta">                    key=&#123;&quot;info&quot;,&quot;error&quot;&#125;,</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(type = &quot;direct&quot;,name=&quot;directs&quot;)</span></span><br><span class="line"><span class="meta">            )&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message1 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings =&#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue(),</span></span><br><span class="line"><span class="meta">                    key=&#123;&quot;error&quot;&#125;,</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(type = &quot;direct&quot;,name=&quot;directs&quot;)</span></span><br><span class="line"><span class="meta">            )&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message2 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="5-5-Topic-订阅模型-动态路由模型"><a href="#5-5-Topic-订阅模型-动态路由模型" class="headerlink" title="5.5 Topic 订阅模型(动态路由模型)"></a>5.5 Topic 订阅模型(动态路由模型)</h3><ol><li><h5 id="开发生产者-4"><a href="#开发生产者-4" class="headerlink" title="开发生产者"></a>开发生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//topic</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopic</span><span class="params">()</span></span>&#123;</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;topics&quot;</span>,<span class="string">&quot;user.save.findAll&quot;</span>,<span class="string">&quot;user.save.findAll 的消息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="开发消费者-4"><a href="#开发消费者-4" class="headerlink" title="开发消费者"></a>开发消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopCustomer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue,</span></span><br><span class="line"><span class="meta">                    key = &#123;&quot;user.*&quot;&#125;,</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;)</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message1 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue,</span></span><br><span class="line"><span class="meta">                    key = &#123;&quot;user.#&quot;&#125;,</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;)</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message2 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr></li></ol><h2 id="6-MQ的应用场景"><a href="#6-MQ的应用场景" class="headerlink" title="6. MQ的应用场景"></a>6. MQ的应用场景</h2><h3 id="6-1-异步处理"><a href="#6-1-异步处理" class="headerlink" title="6.1 异步处理"></a>6.1 异步处理</h3><p><code>场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式</code></p><ul><li><code>串行方式:</code> 将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. </li></ul><p> ![这里写图片描述](RibbitMQ 实战教程.assets/SouthEast-4860248.png)</p><ul><li><code>并行方式: </code>将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。 </li></ul><p> ![这里写图片描述](RibbitMQ 实战教程.assets/SouthEast-20191127211112660.png)</p><ul><li><p><code>消息队列:</code>假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回.  <code>消息队列</code>: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 </p><p>![img](RibbitMQ 实战教程.assets/592892-20190520220249900-1679743651.jpg)</p></li></ul><p>由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。</p><h3 id="6-2-应用解耦"><a href="#6-2-应用解耦" class="headerlink" title="6.2 应用解耦"></a>6.2 应用解耦</h3><p><code>场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口. </code></p><p> ![这里写图片描述](RibbitMQ 实战教程.assets/SouthEast-20191127211247287.png)</p><p>这种做法有一个缺点:</p><p>当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合.  引入消息队列 </p><p> ![这里写图片描述](RibbitMQ 实战教程.assets/SouthEast-20191127211304085.png)</p><ul><li><p><code>订单系统:</code>用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。</p></li><li><p><code>库存系统:</code>订阅下单的消息,获取下单消息,进行库操作。  就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失.</p></li></ul><h3 id="6-3-流量削峰"><a href="#6-3-流量削峰" class="headerlink" title="6.3 流量削峰"></a>6.3 流量削峰</h3><p> <code>场景:</code> 秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。  </p><p>  <code>作用:</code> </p><p>​            1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^) </p><p>​            2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) </p><p> ![这里写图片描述](RibbitMQ 实战教程.assets/SouthEast-20191127211341601.png)</p><p>1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.  </p><p>2.秒杀业务根据消息队列中的请求信息，再做后续处理.</p><hr><h2 id="7-RabbitMQ的集群"><a href="#7-RabbitMQ的集群" class="headerlink" title="7. RabbitMQ的集群"></a>7. RabbitMQ的集群</h2><h3 id="7-1-集群架构"><a href="#7-1-集群架构" class="headerlink" title="7.1 集群架构"></a>7.1 集群架构</h3><h4 id="7-1-1-普通集群-副本集群"><a href="#7-1-1-普通集群-副本集群" class="headerlink" title="7.1.1 普通集群(副本集群)"></a>7.1.1 普通集群(副本集群)</h4><blockquote><p>All data/state required for the operation of a RabbitMQ broker is replicated across all nodes. An exception to this are message queues, which by default reside on one node, though they are visible and reachable from all nodes. To replicate queues across nodes in a cluster   –摘自官网</p></blockquote><p><code>默认情况下:RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管它们可以从所有节点看到和访问</code></p><ol><li><h5 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h5></li></ol><p>![image-20200320094147471](RibbitMQ 实战教程.assets/image-20200320094147471.png)</p><p>​    核心解决问题:  <code>当集群中某一时刻master节点宕机,可以对Quene中信息,进行备份</code></p><ol start="2"><li><h5 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.集群规划</span></span><br><span class="line"><span class="code">node1: 10.15.0.3  mq1  master 主节点</span></span><br><span class="line"><span class="code">node2: 10.15.0.4  mq2  repl1  副本节点</span></span><br><span class="line"><span class="code">node3: 10.15.0.5  mq3  repl2  副本节点</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 1.克隆三台机器主机名和ip映射</span></span><br><span class="line"><span class="code">vim /etc/hosts加入:</span></span><br><span class="line"><span class="code"> 10.15.0.3 mq1</span></span><br><span class="line"><span class="code">    10.15.0.4 mq2</span></span><br><span class="line"><span class="code">    10.15.0.5 mq3</span></span><br><span class="line"><span class="code">node1: vim /etc/hostname 加入:  mq1</span></span><br><span class="line"><span class="code">node2: vim /etc/hostname 加入:  mq2</span></span><br><span class="line"><span class="code">node3: vim /etc/hostname 加入:  mq3</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.三个机器安装rabbitmq,并同步cookie文件,在node1上执行:</span></span><br><span class="line"><span class="code">scp /var/lib/rabbitmq/.erlang.cookie root@mq2:/var/lib/rabbitmq/</span></span><br><span class="line"><span class="code">scp /var/lib/rabbitmq/.erlang.cookie root@mq3:/var/lib/rabbitmq/</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.查看cookie是否一致:</span></span><br><span class="line"><span class="code">node1: cat /var/lib/rabbitmq/.erlang.cookie </span></span><br><span class="line"><span class="code">node2: cat /var/lib/rabbitmq/.erlang.cookie </span></span><br><span class="line"><span class="code">node3: cat /var/lib/rabbitmq/.erlang.cookie </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.后台启动rabbitmq所有节点执行如下命令,启动成功访问管理界面:</span></span><br><span class="line"><span class="code">rabbitmq-server -detached </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.在node2和node3执行加入集群命令:</span></span><br><span class="line"><span class="code">1.关闭       rabbitmqctl stop_app</span></span><br><span class="line"><span class="code">2.加入集群    rabbitmqctl join_cluster rabbit@mq1</span></span><br><span class="line"><span class="code">3.启动服务    rabbitmqctl start_app</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.查看集群状态,任意节点执行:</span></span><br><span class="line"><span class="code">rabbitmqctl cluster_status</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 7.如果出现如下显示,集群搭建成功:</span></span><br><span class="line"><span class="code">Cluster status of node rabbit@mq3 ...</span></span><br><span class="line"><span class="code">[&#123;nodes,[&#123;disc,[rabbit@mq1,rabbit@mq2,rabbit@mq3]&#125;]&#125;,</span></span><br><span class="line"><span class="code">&#123;running_nodes,[rabbit@mq1,rabbit@mq2,rabbit@mq3]&#125;,</span></span><br><span class="line"><span class="code">&#123;cluster_name,&lt;&lt;&quot;rabbit@mq1&quot;&gt;&gt;&#125;,</span></span><br><span class="line"><span class="code">&#123;partitions,[]&#125;,</span></span><br><span class="line"><span class="code">&#123;alarms,[&#123;rabbit@mq1,[]&#125;,&#123;rabbit@mq2,[]&#125;,&#123;rabbit@mq3,[]&#125;]&#125;]</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 8.登录管理界面,展示如下状态:</span></span><br></pre></td></tr></table></figure><p>![image-20200320095613586](RibbitMQ 实战教程.assets/image-20200320095613586.png)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 9.测试集群在node1上,创建队列</span></span><br></pre></td></tr></table></figure><p>![image-20200320095743935](RibbitMQ 实战教程.assets/image-20200320095743935.png)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 10.查看node2和node3节点:</span></span><br></pre></td></tr></table></figure><p>![image-20200320095827688](RibbitMQ 实战教程.assets/image-20200320095827688.png)</p><p>![image-20200320095843370](RibbitMQ 实战教程.assets/image-20200320095843370.png)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 11.关闭node1节点,执行如下命令,查看node2和node3:</span></span><br><span class="line"><span class="code">rabbitmqctl stop_app</span></span><br></pre></td></tr></table></figure><p>![image-20200320100000347](RibbitMQ 实战教程.assets/image-20200320100000347.png)</p><p>![image-20200320100010968](RibbitMQ 实战教程.assets/image-20200320100010968.png)</p><hr></li></ol><h4 id="7-1-2-镜像集群"><a href="#7-1-2-镜像集群" class="headerlink" title="7.1.2 镜像集群"></a>7.1.2 镜像集群</h4><blockquote><p>This guide covers mirroring (queue contents replication) of classic queues  –摘自官网</p><p>By default, contents of a queue within a RabbitMQ cluster are located on a single node (the node on which the queue was declared). This is in contrast to exchanges and bindings, which can always be considered to be on all nodes. Queues can optionally be made <em>mirrored</em> across multiple nodes. –摘自官网</p></blockquote><p><code>镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。</code></p><ol><li><h5 id="集群架构图"><a href="#集群架构图" class="headerlink" title="集群架构图"></a>集群架构图</h5><p>![image-20200320113423235](RibbitMQ 实战教程.assets/image-20200320113423235.png)</p></li><li><h5 id="配置集群架构"><a href="#配置集群架构" class="headerlink" title="配置集群架构"></a>配置集群架构</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.策略说明</span></span><br><span class="line"><span class="code">rabbitmqctl set_policy [-p &lt;vhost&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] &lt;name&gt; &lt;pattern&gt;  &lt;definition&gt;</span></span><br><span class="line"><span class="code">-p Vhost： 可选参数，针对指定vhost下的queue进行设置</span></span><br><span class="line"><span class="code">Name:     policy的名称</span></span><br><span class="line"><span class="code">Pattern: queue的匹配模式(正则表达式)</span></span><br><span class="line"><span class="code">Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode</span></span><br><span class="line"><span class="code">           ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes</span></span><br><span class="line"><span class="code">                        all：表示在集群中所有的节点上进行镜像</span></span><br><span class="line"><span class="code">                        exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span></span><br><span class="line"><span class="code">                        nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</span></span><br><span class="line"><span class="code">             ha-params：ha-mode模式需要用到的参数</span></span><br><span class="line"><span class="code">                ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual</span></span><br><span class="line"><span class="code">                priority：可选参数，policy的优先级</span></span><br><span class="line"><span class="code">                </span></span><br><span class="line"><span class="code">                 </span></span><br><span class="line"><span class="code"># 1.查看当前策略</span></span><br><span class="line"><span class="code">rabbitmqctl list_policies</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.添加策略</span></span><br><span class="line"><span class="code">rabbitmqctl set_policy ha-all &#x27;^hello&#x27; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27; </span></span><br><span class="line"><span class="code">说明:策略正则表达式为 “^” 表示所有匹配所有队列名称  ^hello:匹配hello开头队列</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.删除策略</span></span><br><span class="line"><span class="code">rabbitmqctl clear_policy ha-all</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.测试集群</span></span><br></pre></td></tr></table></figure><hr></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题基础</title>
      <link href="/2021/06/18/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/06/18/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题基础</title>
      <link href="/2021/06/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2021/06/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="JDK-常用的包"><a href="#JDK-常用的包" class="headerlink" title="JDK 常用的包"></a>JDK 常用的包</h1><p><strong>java.io:</strong> 这里面是所有输入输出有关的类，比如文件操作等</p><p><strong>java.net:</strong> 这里面是与网络有关的类，比如 <code>URL</code>,<code>URLConnection</code> 等。</p><p><strong>java.util :</strong> 这个是系统辅助类，特别是集合类 <code>Collection</code>,<code>List</code>,<code>Map</code> 等。</p><p><strong>java.sql:</strong> 这个是数据库操作的类，<code>Connection</code>, <code>Statememt</code>，<code>ResultSet</code> 等</p><h1 id="Get-和-Post-的区别"><a href="#Get-和-Post-的区别" class="headerlink" title="Get 和 Post 的区别"></a>Get 和 Post 的区别</h1><h2 id="初级回答："><a href="#初级回答：" class="headerlink" title="初级回答："></a>初级回答：</h2><ol><li><code>get</code> 是从服务器上获取数据，<code>post</code> 是向服务器传送数据， </li><li><code>get</code> 传送的数据量较小，不能大于 2KB。<code>post</code> 传送的数据量较大，一般被默认为不</li><li><code>get</code> 安全性非常低，<code>post</code> 安全性较高。但是执行效率却比 <code>Post</code> 方法好。 </li><li>在进行文件上传时只能使用 <code>post</code> 而不能是 <code>get</code>。</li></ol><h2 id="中级回答：【推荐】"><a href="#中级回答：【推荐】" class="headerlink" title="中级回答：【推荐】"></a><span style="color:red">中级回答：【推荐】</span></h2><ol><li><p><code>get</code> 是从服务器上获取数据，post 是向服务器传送数据。 </p></li><li><p>get 是把参数数据队列加到提交表单的 <code>ACTION</code> 属性所指的 <code>URL</code> 中，值和表单内各个字段一一对应，在 <code>URL</code> 中可以看到。<code>post</code> 是通过 <code>HTTP post</code> 机制，将表单内各个 字段与其内容放置在 <code>HTML HEADER</code> 内一起传送到 <code>ACTION</code> 属性所指的 <code>URL</code> 地址。用户看不到这个过程。 </p></li><li><p>对于 <code>get</code> 方式，服务器端用 <code>Request.QueryString</code> 获取变量的值，对于 <code>post</code> 方式，服务器端用 <code>Request.Form</code> 获取提交的数据 </p></li><li><p><code>get</code> 传送的数据量较小，不能大于 2KB。<code>post</code> 传送的数据量较大，一般被默认为不受限制。但理论上，<code>IIS4</code> 中最大量为 80KB，<code>IIS5</code>中为 100KB。 </p></li><li><p><code>get</code> 安全性非常低，<code>post</code> 安全性较高</p></li><li><p><code>get</code> 传递参数的时候【有时候】服务端获取的参数不会乱码，而 <code>post</code> 不会，<code>get</code> 请求参数是通过 <code>URL</code> 传递的，浏览器默认的会对中文进行 <code>gbk</code> 编码(<code>URL</code> 中如果含有中文等非 <code>ASCII</code> 字符，则浏览器会对它们进行 <code>URLEncode</code> </p></li></ol><h1 id="Java-多态的具体体现"><a href="#Java-多态的具体体现" class="headerlink" title="Java 多态的具体体现"></a>Java 多态的具体体现</h1><p>面向对象编程有四个特征：抽象，封装，继承，多态。</p><blockquote><p>多态有四种体现形式：</p><ol><li>接口和接口的继承</li><li>类和类的继承</li><li>重载</li><li>重写</li></ol></blockquote><p>其中重载和重写为核心：</p><blockquote><p><strong>重载</strong>：重载发生在同一个类中，在该类中如果存在多个同名方法，但是方法的参数类型和个数不一样，那么说明该方法被重载了。</p><p><strong>重写</strong>：重写发生在子类继承父类的关系中，父类中的方法被子类继承，方法名，返回值类型，参数完全一样，但是方法体不一样，那么说明父类中的该方法被子类重写了。</p></blockquote><h1 id="StringBuffer-StringBuilder-String-区别"><a href="#StringBuffer-StringBuilder-String-区别" class="headerlink" title="StringBuffer StringBuilder String 区别"></a>StringBuffer StringBuilder String 区别</h1><table><thead><tr><th align="center">类型</th><th align="center">底层</th><th align="center">可变性</th><th align="center">安全性</th><th align="center">拼接方式</th></tr></thead><tbody><tr><td align="center">String</td><td align="center">字符串常量</td><td align="center">不可变</td><td align="center">线程安全</td><td align="center">使用字符串拼接时是不同的 2 个空间</td></tr><tr><td align="center">StringBuffer</td><td align="center">字符串变量</td><td align="center">可变</td><td align="center">线程安全</td><td align="center">字符串拼接直接在字符串后追加</td></tr><tr><td align="center">StringBuilder</td><td align="center">字符串变量</td><td align="center">可变</td><td align="center">非线程安全</td><td align="center">字符串拼接直接在字符串后追加</td></tr></tbody></table><ol><li><code>StringBuilder</code> 执行效率高于 <code>StringBuffer</code> 高于 <code>String</code></li><li><code>String</code> 是一个常量，是不可变的，所以对于每一次+=赋值都会创建一个新的对象， <code>StringBuffer</code> 和 <code>StringBuilder</code> 都是可变的，当进行字符串拼接时采用 <code>append</code> 方法，在原来的基础上进行追加，所以性能比 <code>String</code> 要高，又因为 <code>StringBuffer</code> 是线程安全的而 <code>StringBuilder</code> 是线程非安全的，所以 <code>StringBuilder</code> 的效率高于<code>StringBuffer</code></li><li>对于大数据量的字符串的拼接，采用 <code>StringBuffer</code>,<code>StringBuilder</code></li></ol><h1 id="Hashtable-与-HashMap-的区别"><a href="#Hashtable-与-HashMap-的区别" class="headerlink" title="Hashtable 与 HashMap 的区别"></a>Hashtable 与 HashMap 的区别</h1><blockquote><p><code>HashMap</code> 不是线程安全的，<code>HashTable</code> 是线程安全。 </p><p><code>HashMap</code> 允许空（<code>null</code>）的键和值（<code>key</code>），<code>HashTable</code> 则不允许。 </p><p><code>HashMap</code> 性能优于 <code>Hashtable</code>。 </p></blockquote><ol><li><code>Map</code> 是一个以键值对存储的接口。<code>Map</code> 下有两个具体的实现，分别是 <code>HashMap</code> 和 <code>HashTable</code></li><li><code>HashMap</code> 是线程非安全的，<code>HashTable</code> 是线程安全的，所以 <code>HashMap</code> 的效率高于 <code>HashTable</code></li><li><code>HashMap</code> 允许键或值为空，而 <code>HashTable</code> 不允许键或值为空</li></ol><h1 id="九大隐式对象"><a href="#九大隐式对象" class="headerlink" title="九大隐式对象"></a>九大隐式对象</h1><p>输入/输出对象： <code>request</code>、<code>response</code>、<code>out</code></p><p>作用域通信对象： <code>session</code>、<code>application</code>、<code>pageContext</code></p><p>Servlet 对象： <code>page</code>、<code>config</code></p><p>错误对象： <code>exception</code></p><h1 id="Forword-请求转发-与-Redirect-重定向"><a href="#Forword-请求转发-与-Redirect-重定向" class="headerlink" title="Forword(请求转发)与 Redirect(重定向)"></a>Forword(请求转发)与 Redirect(重定向)</h1><ol><li>从数据共享上<ol><li><code>Forword</code> 是一个请求的延续，可以共享 <code>request</code> 的数据</li><li><code>Redirect</code> 开启一个新的请求，不可以共享 <code>request</code> 的数据</li></ol></li><li>从地址栏<ol><li><code>Forword</code> 转发地址栏不发生变化</li><li><code>Redirect</code> 转发地址栏发生变化</li></ol></li></ol><h1 id="JQurey-总结"><a href="#JQurey-总结" class="headerlink" title="JQurey 总结"></a>JQurey 总结</h1><p><code>jquery</code> 是一个轻量级的 <code>js</code> 框架，具有跨浏览器的特性，兼容性好，并且封装了很多工具，方便使用。 </p><p>常用的有: 选择器 ，<code>dom</code> 操作 ，<code>ajax</code>(<code>ajax</code> 不能跨域) ，特效，工具类</p><h1 id="XML-和-Json-的特点"><a href="#XML-和-Json-的特点" class="headerlink" title="XML 和 Json 的特点"></a>XML 和 Json 的特点</h1><p><strong>Xml 特点：</strong></p><ol><li>有且只有一个根节点；</li><li>数据传输的载体 </li><li>所有的标签都需要自定义 </li><li>是纯文本文件 </li></ol><p><strong>Json（JavaScript Object Notation）特点：</strong></p><ol><li><code>json</code> 对象(就是在{}中存储键值对，键和值之间用冒号分隔， 键 值 对之间用逗号分隔)</li><li><code>json</code> 数组(就是[]中存储多个 <code>json</code> 对象，<code>json</code> 对象之间用逗号分隔)（两者间可以进行相互嵌套）数据传输的载体之一</li></ol><p><strong>区别：</strong></p><p>传输同样格式的数据，xml 需要使用更多的字符进行描述，流行的是基于 json 的数据传输,xml 的层次结构比 json 更清晰</p><p><strong>共同点：</strong></p><p>xml 和 json 都是数据传输的载体，并且具有跨平台跨语言的特性。</p><h1 id="Page-和-PageContext-的区别"><a href="#Page-和-PageContext-的区别" class="headerlink" title="Page 和 PageContext 的区别"></a>Page 和 PageContext 的区别</h1><p><code>Page</code> 是 <code>servlet</code> 对象；使用 <code>this</code> 关键字，它的作用范围是在同一页面。<code>PageContext</code> 是作用域通信对象；通常使用<code>setAttribute()</code>和 <code>getAttribute()</code>来设置和获取存放对象的值。</p><h1 id="JSP9-大隐视对象中四个作用域的大小与作用范围"><a href="#JSP9-大隐视对象中四个作用域的大小与作用范围" class="headerlink" title="JSP9 大隐视对象中四个作用域的大小与作用范围"></a>JSP9 大隐视对象中四个作用域的大小与作用范围</h1><p>四个作用域从大到小：<code>appliaction</code> &gt; <code>session</code> &gt; <code>request</code> &gt; <code>page</code></p><table><thead><tr><th align="center">作用域</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">application</td><td align="center">全局作用范围，整个应用程序共享.生命周期为：应用程序启动到停止</td></tr><tr><td align="center">session</td><td align="center">会话作用域，当用户首次访问时，产生一个新的会话，以后服务器就可以记 住这个会话状态</td></tr><tr><td align="center">request</td><td align="center">请求作用域，就是客户端的一次请求</td></tr><tr><td align="center">page</td><td align="center">一个 JSP 页面</td></tr></tbody></table><p>以上作用范围使越来越小， <code>request</code> 和 <code>page</code> 的生命周期都是短暂的，他们之间的区别就是：一个 <code>request</code> 可以包含多个 <code>page</code> 页(<code>include</code>，<code>forward</code>)</p><h1 id="List-Set-Collection-Collections"><a href="#List-Set-Collection-Collections" class="headerlink" title="List,Set,Collection,Collections"></a>List,Set,Collection,Collections</h1><ol><li><code>List</code> 和 <code>Set</code> 都是接口，他们都继承于接口 <code>Collection</code>,<code>List</code> 是一个有序的可重复的集合，而 <code>Set</code> 的无序的不可重复的集合。<code>Collection</code> 是集合的顶层接口，<code>Collections</code> 是一个封装了众多关于集合操作的静态方法的工具类,因为构造方法是私有的，所以不能实例化。</li><li><code>List</code> 接口实现类有 <code>ArrayList</code>,<code>LinkedList</code>,<code>Vector</code>。<code>ArrayList</code> 和 <code>Vector</code> 是基于数组实现的,所以查询的时候速度快，而在进行增加和删除的时候速度较慢 <code>LinkedList</code> 是基于链式存储结构，所以在进行查询的时候速度较慢但在进行增加和删除的时候速度较快。又因为<code>Vector</code> 是线程安全的，所以他和 <code>ArrayList</code> 相比而言，查询效率要低。</li></ol><h1 id="java-的基本数据类型"><a href="#java-的基本数据类型" class="headerlink" title="java 的基本数据类型"></a>java 的基本数据类型</h1><table><thead><tr><th align="center">数据类型</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">byte(字节)</td><td align="center">1(8 位)</td></tr><tr><td align="center">shot(短整型)</td><td align="center">2(16 位)</td></tr><tr><td align="center">int(整型)</td><td align="center">4(32 位)</td></tr><tr><td align="center">long(长整型)</td><td align="center">8(32 位)</td></tr><tr><td align="center">float(浮点型)</td><td align="center">4(32 位)</td></tr><tr><td align="center">double(双精度)</td><td align="center">8(64 位)</td></tr><tr><td align="center">char(字符型)</td><td align="center">2(16 位)</td></tr><tr><td align="center">boolean(布尔型)</td><td align="center">1 位</td></tr></tbody></table><p>附加：</p><ol><li>String 是基本数据类型吗?(String 不是基本数据类型)</li><li>String 的长度是多少，有限制?(长度受内存大小的影响)</li></ol><h1 id="UE-和-UI-的区别"><a href="#UE-和-UI-的区别" class="headerlink" title="UE 和 UI 的区别"></a>UE 和 UI 的区别</h1><blockquote><p>UE 是用户体验度 </p><p>UI 界面原型（用户界面）（相当于买房时用的模型）</p></blockquote><p>设计 UI 的作用： </p><ol><li>帮助程序员工作（界面已由美工设计完成） </li><li>提前让用户对项目有个宏观的了解，知道效果是什么样子。</li></ol><h1 id="osi-七层模型"><a href="#osi-七层模型" class="headerlink" title="osi 七层模型"></a>osi 七层模型</h1><blockquote><p>第一层：物理层 </p><p>第二层：数据链路层 </p><p>第三层：网络层 </p><p>第四层：传输层 </p><p>第五层：会话层 </p><p>第六层：表示层 </p><p>第七层：应用层</p></blockquote><h1 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h1><ol><li>线程(Thread)与进程（Process）进程定义的是应用程序与应用程序之间的边界，通常来说一个进程就代表一个与之对应的应用程序。不同的进程之间不能共享代码和数据空间，而同一进程的不同线程可以共享代码和数据空间。 </li><li>.一个进程可以包括若干个线程，同时创建多个线程来完成某项任务，便是多线程</li><li>实现线程的两种方式：继承 Thread 类，实现 Runable 接口</li></ol><h1 id="jvm-的内存结构"><a href="#jvm-的内存结构" class="headerlink" title="jvm 的内存结构"></a>jvm 的内存结构</h1><p><code>java</code> 虚拟机的内存结构分为堆(<code>heap</code>)和栈(<code>stack</code>),堆里面存放是对象实例也就是 <code>new</code>出来的对象。栈里面存放的是基本数据类型以及引用数据类型的地址。</p><p>对于所谓的常量是存储在方法区的常量池里面</p><h1 id="内存泄露和内存溢出"><a href="#内存泄露和内存溢出" class="headerlink" title="内存泄露和内存溢出"></a>内存泄露和内存溢出</h1><p>内存泄露 (<code>memory leak</code>)，是指应用程序在申请内存后，无法释放已经申请的内存空间.一次内存泄露危害可以忽略，但如果任其发展最终会导致内存溢出(<code>out of memory</code>).如读取文件后流要进行及时的关闭以及对数据库连接的释放。</p><p>内存溢出（<code>out of memory</code>）是指应用程序在申请内存时，没有足够的内存空间供其使用。如我们在项目中对于大批量数据的导入，采用分段批量提交的方式。</p><h1 id="项目的生命周期"><a href="#项目的生命周期" class="headerlink" title="项目的生命周期"></a>项目的生命周期</h1><blockquote><p>1.需求分析 </p><p>2.概要设计 </p><p>3.详细设计(用例图，流程图，类图) </p><p>4.数据库设计(powerdesigner) </p><p>5.代码开发（编写） </p><p>6.单元测试（junit 白盒测试）(开发人员) </p><p>svn 版本管理工具(提交，更新代码，文档) </p><p>7.集成测试 （黑盒测试，loadrunner（编写测试脚本）(高级测试)） </p><p>8.上线试运行 （用户自己体验） </p><p>9.压力测试（loadrunner） </p><p>10.正式上线 </p><p>11.维护 </p></blockquote><h1 id="session-和-cookie-的区别"><a href="#session-和-cookie-的区别" class="headerlink" title="session 和 cookie 的区别"></a>session 和 cookie 的区别</h1><p><code>session</code> 是存储在服务器端，<code>cookie</code> 是存储在客户端的，所以安全来讲 <code>session</code> 的安全性要比<code>cookie</code> 高，然后我们获取 <code>session</code> 里的信息是通过存放在会话 <code>cookie</code> 里的 <code>sessionid</code> 获取的。又由于 <code>session</code> 是存放在服务器的内存中，所以 <code>session</code> 里的东西不断增加会造成服务器的负担，所以会把很重要的信息存储在 <code>session</code> 中，而把一些次要东西存储在客户端的 <code>cookie</code> 里，然后 <code>cookie</code> 确切的说分为两大类分为会话 <code>cookie</code> 和持久化 <code>cookie</code>，会话 <code>cookie</code> 确切的说是，存放在客户端浏览器的内存中,所以说他的生命周期和浏览器是一致的，浏览器关了会话<code>cookie</code> 也就消失了，然而持久化 <code>cookie</code> 是存放在客户端硬盘中，而持久化 <code>cookie</code> 的生命周期就是我们在设置 <code>cookie</code> 时候设置的那个保存时间，然后我们考虑一问题当浏览器关闭时<code>session</code> 会不会丢失，从上面叙述分析 <code>session</code> 的信息是通过会话 <code>cookie</code> 的 <code>sessionid</code> 获取的，当浏览器关闭的时候会话 <code>cookie</code> 消失所以我们的 <code>sessionid</code> 也就消失了，但是 <code>session</code> 的信息还存在服务器端，<span style="background:red">这时我们只是查不到所谓的 <code>session</code> 但它并不是不存在</span>。那么，<code>session</code> 在什么情况下丢失，就是在服务器关闭的时候，或者是 <code>session</code> 过期(默认时间是 30 分钟)，再或 者 调 用 了 <code>invalidate()</code> 的 或 者 是 我 们 想 要 <code>session</code> 中 的 某 一 条 数 据 消 失 调 用<code>session.removeAttribute()</code>方法，然后 <code>session</code> 在什么时候被创建呢，确切的说是通过调用<code>getsession()</code>来创建，这就是 <code>session</code> 与 <code>cookie</code> 的区别.</p><p><span style="color:blue">访问 <code>HTML</code> 页面是不会创建 <code>session</code>,但是访问 <code>index.JSP</code> 时会创建 <code>session</code>(<code>JSP</code> 实际上是一个 <code>Servlet</code>, <code>Servlet</code> 中有 <code>getSession</code> 方法) </span></p><h1 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h1><p><code>stream</code> 结尾都是字节流，<code>reader</code> 和 <code>writer</code> 结尾都是字符流 </p><p>区别:读写的时候一个是按字节读写，一个是按字符。 </p><p>在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。 </p><p>只是读写文件，和文件内容无关的，一般选择字节流。</p><h1 id="final-finally-finalize-三者区别"><a href="#final-finally-finalize-三者区别" class="headerlink" title="final,finally,finalize 三者区别"></a>final,finally,finalize 三者区别</h1><blockquote><p><code>Final</code> 是一个修饰符： </p><p>当 <code>final</code> 修饰一个变量的时候，变量变成一个常量，它不能被二次赋值当 <code>final</code> 修饰的变量为静态变量（即由 <code>static</code> 修饰）时，必须在声明这个变量的时候给它赋值</p><p>当 <code>final</code> 修饰方法时，该方法不能被重写 </p><p>当 <code>final</code> 修饰类时，该类不能被继承 </p><p><code>Final</code> 不能修饰抽象类，因为抽象类中会有需要子类实现的抽象方法，（抽象类中可以有抽象方法，也可以有普通方法，当一个抽象类中没有抽象方法时，这个抽象类也就没有了它存在的必要） </p><p><code>Final</code> 不能修饰接口，因为接口中有需要其实现类来实现的方法</p></blockquote><blockquote><p><code>Finally</code>： </p><p><code>Finally</code> 只能与 <code>try</code>/<code>catch</code> 语句结合使用，<code>finally</code> 语句块中的语句一定会执行， 并且会在<code>return</code>，<code>continue</code>，<code>break</code> 关键字之前执行</p></blockquote><blockquote><p><code>finalize</code>： </p><p><code>Finalize</code> 是一个方法，属于 <code>java.lang.Object</code> 类，<code>finalize()</code>方法是 <code>GC</code>（<code>garbage collector</code> 垃圾回收）运行机制的一部分，<code>finalize()</code>方法是在 <code>GC</code> 清理它所从属的对象时被调用的</p></blockquote><h1 id="JavaSE-JavaEE-JavaME区别"><a href="#JavaSE-JavaEE-JavaME区别" class="headerlink" title="JavaSE JavaEE JavaME区别"></a>JavaSE JavaEE JavaME区别</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><div class="note success modern"><p>Java SE = Java Standard Edition = j2se = java 标准版 </p></div><div class="note success modern"><p>Java EE = Java Enterprise Edition = j2ee = java 企业版 </p></div><div class="note success modern"><p>Java ME = Java Mobile Edition = j2me = java 移动版 </p></div><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>SE 主要用于桌面程序（swing）,控制台开发(main 程序)。</p><p>EE 企业级开发(JSP,EJB,Spring MVC,Struts,hibernate,ibatis 等)，用于企业级软件开发，网络开发，web 开发。</p><p>ME 嵌入式开发(手机,小家电，PDA)。[苹果的 ios，黑莓] </p><h2 id="三者之间的关系："><a href="#三者之间的关系：" class="headerlink" title="三者之间的关系："></a>三者之间的关系：</h2><p>Java SE（Java Platform, Standard Edition，Java 标准版）就是基于 JDK 和 JRE的。</p><p>Java SE 为 Java EE 提供了基础。</p><p>Java EE 除了基于我们这个所谓的 Java SE 外，还新加了企业应用所需的类库</p><h1 id="JDK-JRE-JVM-的区别："><a href="#JDK-JRE-JVM-的区别：" class="headerlink" title="JDK JRE JVM 的区别："></a>JDK JRE JVM 的区别：</h1><h2 id="JDK："><a href="#JDK：" class="headerlink" title="JDK："></a>JDK：</h2><p><strong>【Java Development ToolKit】</strong>就是 <code>java</code> 开发工具箱， <strong>JDK</strong> 是整个 <strong>JAVA</strong> 的核心里边包含了 <strong>jre</strong>，它除了包含 <strong>jre</strong> 之外还包含了一些 <strong>javac</strong> 的工具类，把 <strong>java</strong> 源文件编译成 <strong>class</strong> 文件，<strong>java</strong> 文件是用来运行这个程序的，除此之外，里边还包含了 <strong>java</strong>源生的 <strong>API</strong>，<code>java.lang.integer</code> 在 <strong>return</strong>  的 <strong>jar</strong> 包里边【可以在项目中看到】，通过 <strong>return</strong> 这个 <strong>jar</strong> 包来调用我们的这些 <strong>io</strong> 流写入写出等</p><h3 id="JDK-有以下三种版本："><a href="#JDK-有以下三种版本：" class="headerlink" title="JDK 有以下三种版本："></a>JDK 有以下三种版本：</h3><blockquote><p>J2SE，standard edition，标准版，是我们通常用的一个版本 </p><p>J2EE，enterpsise edtion，企业版，使用这种 JDK 开发 J2EE 应用程序 </p><p>J2ME，micro edtion，主要用于移动设备、嵌入式设备上的 java 应用程序</p></blockquote><h2 id="JRE："><a href="#JRE：" class="headerlink" title="JRE："></a>JRE：</h2><p><strong>【Java Runtime Enviromental】</strong>是 <code>java</code> 运行时环境，那么所谓的 <code>java</code> 运行时环境，就是为了保证 <code>java</code> 程序能够运行时，所必备的一基础环境，也就是它只是保证 <code>java</code> 程序运行的，不能用来开发，而 <code>jdk</code> 才是用来开发的，所有的 <strong>Java</strong> 程序都要在<strong>JRE</strong> 下才能运行。</p><p>包括 <strong>JVM</strong> 和 <strong>JAVA</strong> 核心类库和支持文件。与 <strong>JDK</strong> 相比，它不包含开发工具——编译器、调试器和其它工具。</p><div class="note warning modern"><p>JRE里面包含JVM</p></div><h2 id="Jvm："><a href="#Jvm：" class="headerlink" title="Jvm："></a>Jvm：</h2><p><strong>【Java Virtual Mechinal</strong>】因为 <code>jre</code> 是 <code>java</code> 运行时环境，<code>java</code> 运行靠什么运行，而底层就是依赖于 <code>jvm</code>，即 <code>java</code> 虚拟机，<code>java</code> 虚拟机用来加载类文件，<code>java</code> 中之所以有跨平台的作用，就是因为我们的 <code>jvm</code> </p><h2 id="关系："><a href="#关系：" class="headerlink" title="关系："></a>关系：</h2><div class="note success modern"><p>J2se 是基于 jdk 和 jre，JDK 是整个 JAVA 的核心里边包含了 jre，Jre 里边包含 jvm</p></div><h1 id="报错的状态码："><a href="#报错的状态码：" class="headerlink" title="报错的状态码："></a>报错的状态码：</h1><table><thead><tr><th align="center">状态码</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">301</td><td align="center">永久重定向</td></tr><tr><td align="center">302</td><td align="center">临时重定向</td></tr><tr><td align="center">304</td><td align="center">服务端 未改变</td></tr><tr><td align="center">403</td><td align="center">访问无权限</td></tr><tr><td align="center">200</td><td align="center">正常</td></tr><tr><td align="center">404</td><td align="center">路径</td></tr><tr><td align="center">500</td><td align="center">内部错误</td></tr></tbody></table><h1 id="协议以及默认的端口号"><a href="#协议以及默认的端口号" class="headerlink" title="协议以及默认的端口号"></a>协议以及默认的端口号</h1><table><thead><tr><th align="center">协议</th><th align="center">端口</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">ftp</td><td align="center">21</td><td align="center">文件传输协议</td></tr><tr><td align="center">Pop3</td><td align="center">110</td><td align="center">它是因特网电子邮箱的第一个离线协议标准</td></tr><tr><td align="center">Smtp</td><td align="center">25</td><td align="center">简单邮件传输协议</td></tr><tr><td align="center">http</td><td align="center">80</td><td align="center">超文本传输协议</td></tr><tr><td align="center">oracle</td><td align="center">1521</td><td align="center">默认端口号</td></tr><tr><td align="center">mysql</td><td align="center">3306</td><td align="center">默认端口号</td></tr></tbody></table><h1 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h1><ol><li>一个类只能进行单继承，但可以实现多个接口。</li><li>有抽象方法的类一定是抽象类，但是抽象类里面不一定有抽象方法；接口里面所有的方法的默认修饰符为 <code>public abstract</code>，接口里的成员变量默认的修饰符为 <code>pulbic static final</code>。</li></ol><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><blockquote><p>接口和接口       ==&gt;     继承 </p><p>接口和抽象类   ==&gt;     抽象类实现接口 </p><p>类和抽象类      ==&gt;     类继承抽象类 </p><p>类和类             ==&gt;     继承</p></blockquote><h1 id="request-跟-session-的区别"><a href="#request-跟-session-的区别" class="headerlink" title="request 跟 session 的区别"></a>request 跟 session 的区别</h1><ol><li>他们的生命周期不同，<code>request</code>对应的是一次请求，<code>session</code>对应的是一次会话 </li><li><code>request</code>占用资源比较少,相对来说缺乏持续性,而<code>session</code>资源消耗比较大，所以通常使用<code>request</code>来保存信息</li></ol><h1 id="反射的描述"><a href="#反射的描述" class="headerlink" title="反射的描述"></a>反射的描述</h1><p>通过字符串可以动态创建<code>java</code>对象，并且可以动态访问方法，属性等。 </p><p>我们在项目中的时候封装过数据库<code>jdbc</code>的持久层，其中就利用反射这项技术来达到通用和灵活的目的。 </p></article>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
